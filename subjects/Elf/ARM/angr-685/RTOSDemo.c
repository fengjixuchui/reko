// RTOSDemo.c
// Generated by decompiling RTOSDemo.axf
// using Reko decompiler version 0.8.1.0.

#include "RTOSDemo.h"

// 00000058: void prvUnlockQueue(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void prvUnlockQueue(Eq_n * r0, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	int32 r4_n = (int32) (int8) (word32) r0->b0045;
	if (r4_n > 0x00 && r0->dw0024 != 0x00)
	{
		do
		{
			xTaskRemoveFromEventList(&r0->dw0024);
			if (0x00 != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (r0->dw0024 != 0x00);
	}
	r0->b0045 = ~0x00;
	vPortExitCritical(cpsr);
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	int32 r4_n = (int32) (int8) (word32) r0->b0044;
	if (r4_n > 0x00 && r0->dw0010 != 0x00)
	{
		do
		{
			xTaskRemoveFromEventList(&r0->dw0010);
			if (0x00 != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
			else
			{
				uint32 r3_n = (uint32) (byte) (r4_n - 0x01);
				r4_n = (int32) (int8) r3_n;
				if (r3_n == 0x00)
					break;
			}
		} while (r0->dw0010 != 0x00);
	}
	r0->b0044 = ~0x00;
	vPortExitCritical(cpsr);
}

// 000000EC: FlagGroup byte prvCopyDataToQueue(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register word32 r2, Register out ptr32 r0Out)
byte prvCopyDataToQueue(Eq_n * r0, Eq_n * r1, word32 r2, ptr32 & r0Out)
{
	byte Z_n;
	struct Eq_n * r0_n = r0->ptr0040;
	*r0Out = r0_n;
	up32 r5_n = r0->dw0038;
	if (r0_n == null)
	{
		struct Eq_n * r6_n = r0->ptr0000;
		if (r6_n != null)
		{
			++r5_n;
			Z_n = cond(r5_n + 0x01);
		}
		else
		{
			word32 r0_n;
			*r0Out = xTaskPriorityDisinherit(r0->ptr0004);
			r0->ptr0004 = r6_n;
			++r5_n;
			Z_n = cond(r5_n + 0x01);
		}
	}
	else
	{
		if (r2 == 0x00)
		{
			memcpy(r0->ptr0008, r1, r0_n);
			struct Eq_n * r2_n = r0->ptr0004;
			word32 r3_n = Mem0[r0 + 0x08:word32] + Mem0[r0 + 0x0040:word32];
			r0->ptr0008 = r3_n;
			if (r3_n < r2_n)
			{
				r0->dw0038 = r5_n + 0x01;
				word32 r0_n;
				*r0Out = r2;
				return cond(r5_n + 0x01);
			}
			else
			{
				r0->ptr0008 = r0->ptr0000;
				r0->dw0038 = r5_n + 0x01;
				word32 r0_n;
				*r0Out = r2;
				return cond(r5_n + 0x01);
			}
		}
		memcpy(r0->ptr000C, r1, r0_n);
		struct Eq_n * r3_n = r0->ptr000C;
		struct Eq_n * r1_n = r0->ptr0000;
		r0->ptr000C = r3_n;
		if (r3_n < r1_n)
			r0->ptr000C = r0->ptr0004;
		Z_n = cond(r2 - 0x02);
		if (r2 != 0x02)
		{
			r0->dw0038 = r5_n + 0x01;
			word32 r0_n;
			*r0Out = 0x00;
			return cond(r5_n + 0x01);
		}
		if (r5_n == 0x00)
			r5_n = 0x01;
		word32 r0_n;
		*r0Out = 0x00;
	}
	r0->dw0038 = r5_n;
	return Z_n;
}

// 0000016C: void prvCopyDataFromQueue(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
void prvCopyDataFromQueue(Eq_n * r0, Eq_n * r1)
{
	struct Eq_n * r2_n = r0->ptr0040;
	if (r2_n == null)
		return;
	struct Eq_n * r4_n = r0->ptr0004;
	word32 r1_n = Mem0[r0 + 0x0C:word32] + r2_n;
	r0->ptr000C = r1_n;
	if (r1_n >= r4_n)
		r1_n = r0->ptr0000;
	r0->ptr000C = r1_n;
	memcpy(r1, r1_n, r2_n);
}

// 00000190: void xQueueGenericSend(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register up32 r2, Register word32 r3, Register word32 cpsr)
void xQueueGenericSend(Eq_n * r0, Eq_n * r1, up32 r2, word32 r3, word32 cpsr)
{
	word32 r5_n = 0x00;
	word32 * r9_n = globals->ptr02A0;
	while (true)
	{
		word32 r0_n;
		vPortEnterCritical(cpsr, out r0_n);
		if (r0->dw0038 < r0->dw003C || r3 == 0x02)
			break;
		if (r2 == 0x00)
		{
			vPortExitCritical(cpsr);
			return;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 0x0028);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		word32 r0_n;
		vPortEnterCritical(cpsr, out r0_n);
		if ((word32) r0->b0044 == 0xFF)
			r0->b0044 = 0x00;
		if ((word32) r0->b0045 == 0xFF)
			r0->b0045 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 0x0028, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			return;
		}
		word32 r0_n;
		vPortEnterCritical(cpsr, out r0_n);
		if (r0->dw0038 != r0->dw003C)
		{
			vPortExitCritical(cpsr);
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
		}
		else
		{
			vPortExitCritical(cpsr);
			vTaskPlaceOnEventList(&r0->dw0010, r2);
			prvUnlockQueue(r0, cpsr);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*r9_n = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
		}
		r5_n = 0x01;
	}
	word32 r0_n;
	prvCopyDataToQueue(r0, r1, r3, out r0_n);
	if (r0->dw0024 == 0x00)
	{
		if (r0_n == 0x00)
			goto l00000266;
	}
	else
	{
		xTaskRemoveFromEventList(&r0->dw0024);
		if (true)
			goto l00000266;
	}
	*globals->ptr02A0 = 0x10000000;
	__dsb_sy();
	__isb_sy();
l00000266:
	vPortExitCritical(cpsr);
}

// 000002A4: void xQueuePeekFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register word32 cpsr)
void xQueuePeekFromISR(Eq_n * r0, Eq_n * r1, word32 cpsr)
{
	struct Eq_n * r5_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	if (r0->dw0038 != 0x00)
	{
		struct Eq_n * r6_n = r0->ptr000C;
		prvCopyDataFromQueue(r0, r1);
		r0->ptr000C = r6_n;
		__msr(cpsr, r5_n);
	}
	else
		__msr(cpsr, r5_n);
}

// 000002D8: Register (ptr32 Eq_n) xQueueGenericReceive(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register up32 r2, Register word32 r3, Register word32 cpsr)
Eq_n * xQueueGenericReceive(Eq_n * r0, Eq_n * r1, up32 r2, word32 r3, word32 cpsr)
{
	word32 r5_n = 0x00;
	word32 * r8_n = globals->ptr0424;
	while (true)
	{
		word32 r0_n;
		vPortEnterCritical(cpsr, out r0_n);
		up32 r6_n = r0->dw0038;
		if (r6_n != 0x00)
			break;
		if (r2 == 0x00)
		{
l000003A4:
			vPortExitCritical(cpsr);
			return null;
		}
		if (r5_n == 0x00)
			vTaskSetTimeOutState(fp - 0x0028);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		word32 r0_n;
		vPortEnterCritical(cpsr, out r0_n);
		if ((word32) r0->b0044 == 0xFF)
			r0->b0044 = 0x00;
		if ((word32) r0->b0045 == 0xFF)
			r0->b0045 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 0x0028, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			word32 r0_n;
			vPortEnterCritical(cpsr, out r0_n);
			if (r0->dw0038 == 0x00)
				goto l000003A4;
			vPortExitCritical(cpsr);
		}
		else
		{
			word32 r0_n;
			vPortEnterCritical(cpsr, out r0_n);
			if (r0->dw0038 != 0x00)
			{
				vPortExitCritical(cpsr);
				prvUnlockQueue(r0, cpsr);
				xTaskResumeAll(cpsr);
			}
			else
			{
				vPortExitCritical(cpsr);
				if (r0->ptr0000 == null)
				{
					word32 r0_n;
					vPortEnterCritical(cpsr, out r0_n);
					vTaskPriorityInherit(r0->ptr0004);
					vPortExitCritical(cpsr);
				}
				vTaskPlaceOnEventList(&r0->dw0024, r2);
				prvUnlockQueue(r0, cpsr);
				if (xTaskResumeAll(cpsr) == 0x00)
				{
					*r8_n = 0x10000000;
					__dsb_sy();
					__isb_sy();
				}
			}
		}
		r5_n = 0x01;
	}
	struct Eq_n * r5_n = r0->ptr000C;
	prvCopyDataFromQueue(r0, r1);
	if (r3 == 0x00)
	{
		struct Eq_n * r3_n = r0->ptr0000;
		r0->dw0038 = r6_n - 0x01;
		if (r3_n == null)
			r0->ptr0004 = pvTaskIncrementMutexHeldCount();
		if (r0->dw0010 == 0x00)
			goto l000003CC;
		xTaskRemoveFromEventList(&r0->dw0010);
		if (true)
			goto l000003CC;
	}
	else
	{
		word32 r3_n = r0->dw0024;
		r0->ptr000C = r5_n;
		if (r3_n == 0x00)
			goto l000003CC;
		xTaskRemoveFromEventList(&r0->dw0024);
		if (0x00 == 0x00)
		{
l000003CC:
			vPortExitCritical(cpsr);
			return &globals->t0001;
		}
	}
	*globals->ptr0424 = 0x10000000;
	__dsb_sy();
	__isb_sy();
	goto l000003CC;
}

// 00000428: void uxQueueMessagesWaiting(Register word32 r0, Register word32 cpsr)
void uxQueueMessagesWaiting(word32 r0, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	vPortExitCritical(cpsr);
}

// 0000043C: void uxQueueSpacesAvailable(Register word32 r0, Register word32 cpsr)
void uxQueueSpacesAvailable(word32 r0, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	vPortExitCritical(cpsr);
}

// 00000454: void vQueueDelete()
void vQueueDelete()
{
	vPortFree();
}

// 00000458: void xQueueGenericSendFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 word32) r2, Register word32 r3, Register word32 cpsr)
void xQueueGenericSendFromISR(Eq_n * r0, Eq_n * r1, word32 * r2, word32 r3, word32 cpsr)
{
	struct Eq_n * r6_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	if (r0->dw0038 < r0->dw003C || r3 == 0x02)
	{
		int32 r4_n = (int32) (int8) (word32) r0->b0045;
		word32 r0_n;
		if (!prvCopyDataToQueue(r0, r1, r3, out r0_n))
			r0->b0045 = (byte) (int32) (int8) (r4_n + 0x01);
		else if (r0->dw0024 != 0x00)
		{
			xTaskRemoveFromEventList(&r0->dw0024);
			if (0x00 != 0x00 && r2 != null)
			{
				*r2 = 0x01;
				goto l0000047C;
			}
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l0000047C:
		__msr(cpsr, r6_n);
	}
}

// 000004C4: void xQueueGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register word32 cpsr)
void xQueueGiveFromISR(Eq_n * r0, word32 * r1, word32 cpsr)
{
	struct Eq_n * r4_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	up32 r2_n = r0->dw0038;
	if (r2_n >= r0->dw003C)
	{
		__msr(cpsr, r4_n);
		return;
	}
	int32 r3_n = (int32) (int8) (word32) r0->b0045;
	r0->dw0038 = r2_n + 0x01;
	if (r2_n != 0x01)
		r0->b0045 = (byte) (int32) (int8) (r3_n + 0x01);
	else if (r0->dw0024 != 0x00)
	{
		xTaskRemoveFromEventList(&r0->dw0024);
		if (0x00 != 0x00 && r1 != null)
		{
			*r1 = 0x01;
l000004FA:
			__msr(cpsr, r4_n);
			return;
		}
	}
	goto l000004FA;
}

// 00000524: void xQueueReceiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 word32) r2, Register word32 cpsr)
void xQueueReceiveFromISR(Eq_n * r0, Eq_n * r1, word32 * r2, word32 cpsr)
{
	struct Eq_n * r6_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	up32 r4_n = r0->dw0038;
	if (r4_n != 0x00)
	{
		int32 r5_n = (int32) (int8) (word32) r0->b0044;
		prvCopyDataFromQueue(r0, r1);
		r0->dw0038 = r4_n - 0x01;
		if (r4_n != 0x01)
			r0->b0044 = (byte) (int32) (int8) (r5_n + 0x01);
		else if (r0->dw0010 != 0x00)
		{
			xTaskRemoveFromEventList(&r0->dw0010);
			if (0x00 != 0x00 && r2 != null)
			{
				*r2 = 0x01;
				goto l00000542;
			}
		}
		__msr(cpsr, r6_n);
	}
	else
	{
l00000542:
		__msr(cpsr, r6_n);
	}
}

// 00000594: void xQueueIsQueueEmptyFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueEmptyFromISR(Eq_n * r0)
{
	__clz(r0->dw0038);
}

// 000005A0: void xQueueIsQueueFullFromISR(Register (ptr32 Eq_n) r0)
void xQueueIsQueueFullFromISR(Eq_n * r0)
{
	__clz(r0->dw003C - r0->dw0038);
}

// 000005B0: void uxQueueMessagesWaitingFromISR(Register word32 r0)
void uxQueueMessagesWaitingFromISR(word32 r0)
{
}

// 000005B4: void xQueueGetMutexHolder(Register (ptr32 word32) r0, Register word32 cpsr)
void xQueueGetMutexHolder(word32 * r0, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if (*r0 != 0x00)
		vPortExitCritical(cpsr);
	else
		vPortExitCritical(cpsr);
}

// 000005D4: void xQueueTakeMutexRecursive(Register (ptr32 Eq_n) r0, Register up32 r1, Register word32 cpsr)
void xQueueTakeMutexRecursive(Eq_n * r0, up32 r1, word32 cpsr)
{
	if (r0->ptr0004 == xTaskGetCurrentTaskHandle())
		r0->ptr000C = (struct Eq_n *) ((char *) &r0->ptr000C->t0000 + 0x01);
	else if (xQueueGenericReceive(r0, null, r1, 0x00, cpsr) != 0x00)
		r0->ptr000C = (struct Eq_n *) ((char *) &r0->ptr000C->t0000 + 0x01);
}

// 00000604: void xQueueGiveMutexRecursive(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void xQueueGiveMutexRecursive(Eq_n * r0, word32 cpsr)
{
	if (r0->ptr0004 != xTaskGetCurrentTaskHandle())
		return;
	struct Eq_n * r3_n = r0->ptr000C;
	r0->ptr000C = r3_n - 0x01;
	if (r3_n != &globals->t0001)
		return;
	xQueueGenericSend(r0, r3_n - 0x01, r3_n - 0x01, r3_n - 0x01, cpsr);
}

// 00000630: void xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register word32 cpsr)
void xQueueGenericReset(Eq_n * r0, word32 r1, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	ui32 r3_n = r0->dw0040;
	ui32 r2_n = r0->ptr003C * r3_n;
	struct Eq_n * r0_n = r0->ptr0000;
	r0->dw0038 = 0x00;
	r0->dw0004 = r0_n + r2_n / 0x0066;
	r0->ptr0044 = &globals->tFFFFFFFF;
	r0->dw000C = r0_n + (r2_n - r3_n) / 0x0066;
	r0->ptr0008 = r0_n;
	r0->b0045 = ~0x00;
	if (r1 != 0x00)
	{
		vListInitialise(&r0->ptr0010);
		vListInitialise(&r0->ptr0024);
		vPortExitCritical(cpsr);
	}
	else
	{
		if (r0->ptr0010 != null)
		{
			xTaskRemoveFromEventList(&r0->ptr0010);
			if (0x00 != 0x00)
			{
				*globals->ptr06A8 = 0x10000000;
				__dsb_sy();
				__isb_sy();
				vPortExitCritical(cpsr);
				return;
			}
		}
		vPortExitCritical(cpsr);
	}
}

// 000006AC: Register (ptr32 Eq_n) xQueueGenericCreate(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
Eq_n * xQueueGenericCreate(Eq_n * r0, ui32 r1, word32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(r0 * r1 + 0x48, cpsr);
	if (r0_n != null)
	{
		if (r1 != 0x00)
			r0_n->ptr0000 = &r0_n->b0045 + 0x03;
		else
			r0_n->ptr0000 = r0_n;
		r0_n->ptr003C = r0;
		r0_n->dw0040 = r1;
		xQueueGenericReset(r0_n, 0x01, cpsr);
	}
	return r0_n;
}

// 000006DC: void xQueueCreateMutex(Register word32 cpsr)
void xQueueCreateMutex(word32 cpsr)
{
	struct Eq_n * r0_n = xQueueGenericCreate(&globals->t0001, 0x00, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0004 = null;
		r0_n->ptr0000 = null;
		r0_n->ptr000C = null;
		xQueueGenericSend(r0_n, null, 0x00, 0x00, cpsr);
	}
}

// 00000700: void prvInitialiseNewTask(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04, Stack (ptr32 Eq_n) dwArg08, Stack (ptr32 Eq_n) dwArg0C)
void prvInitialiseNewTask(ui32 r0, word32 r1, ui32 r2, word32 r3, int32 dwArg00, Eq_n * * dwArg04, Eq_n * dwArg08, Eq_n * dwArg0C)
{
	byte * r3_n = r1 - 0x01 + 0x01;
	struct Eq_n * r5_n = dwArg08->ptr0050 + (r2 + 0x3FFFFFFF << 0x02) / 0x0066 & ~0x07;
	byte * r0_n = (char *) &dwArg08->ptr0050 + 0x04;
	uint32 r2_n = dwArg00 & ~0x80000000;
	do
	{
		*r0_n = (byte) (word32) *r3_n;
		++r3_n;
		++r0_n;
	} while ((word32) *r3_n != 0x00 && r3_n != r1 + 0x02);
	if (r2_n >= 0x01)
		r2_n = 0x01;
	dwArg08->dw004C = r2_n;
	dwArg08->dw0058 = r2_n;
	dwArg08->b0056 = 0x00;
	dwArg08->dw005C = 0x00;
	vListInitialiseItem(&dwArg08->ptr0024);
	vListInitialiseItem(&dwArg08->dw0038);
	dwArg08->dw0038 = 0x02 - r2_n;
	struct Eq_n * r2_n = dwArg08->ptr0050;
	dwArg08->ptr0030 = dwArg08;
	dwArg08->ptr0044 = dwArg08;
	vPortStoreTaskMPUSettings(&dwArg08->dw0004, dwArg0C, r2_n, r2);
	dwArg08->dw0060 = 0x00;
	dwArg08->b0064 = 0x00;
	dwArg08->ptr0000 = pxPortInitialiseStack(r5_n, r0, r3, dwArg00 >> 0x1F);
	if (dwArg04 != null)
		*dwArg04 = (struct Eq_n **) dwArg08;
}

// 00000798: void prvAddNewTaskToReadyList(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void prvAddNewTaskToReadyList(Eq_n * r0, word32 cpsr)
{
	uint32 r0_n;
	struct Eq_n * r4_n = globals->ptr0854;
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	++r4_n->dw0000;
	if (r4_n->ptr0004 != null)
	{
		if (r4_n->dw0074 != 0x00)
		{
l000007B4:
			r0_n = r0->dw004C;
			goto l000007BA;
		}
		r0_n = r0->dw004C;
		if (r4_n->ptr0004->dw004C <= r0_n)
			r4_n->ptr0004 = r0;
	}
	else
	{
		r4_n->ptr0004 = r0;
		if (r4_n->dw0000 != 0x01)
			goto l000007B4;
		vListInitialise((char *) &r4_n->ptr0004 + 0x04);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0018);
		vListInitialise((char *) &r4_n->ptr0004 + 44);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0040);
		vListInitialise((char *) &r4_n->ptr0004 + 0x0054);
		r4_n->ptr006C = (char *) &r4_n->ptr0004 + 44;
		r0_n = r0->dw004C;
		r4_n->ptr0070 = (char *) &r4_n->ptr0004 + 0x0040;
	}
l000007BA:
	word32 r2_n = r4_n->dw0078;
	r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
	r4_n->dw0078 = r2_n + 0x01;
	vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14, &r0->ptr0024);
	vPortExitCritical(cpsr);
	if (r4_n->dw0074 != 0x00 && (r4_n->ptr0004)->dw004C < r0->dw004C)
	{
		*globals->ptr0858 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
}

// 0000085C: void prvAddCurrentTaskToDelayedList.isra.0(Register up32 r0)
void prvAddCurrentTaskToDelayedList.isra.0(up32 r0)
{
	struct Eq_n * r4_n = globals->ptr08B0;
	up32 r6_n = r4_n->dw0080;
	if (uxListRemove(&r4_n->ptr0004->dw0024) == 0x00)
		r4_n->dw007C &= ~(0x01 << (r4_n->ptr0004)->dw004C << 0x00);
	up32 r5_n = r0 + r6_n;
	r4_n->ptr0004->dw0024 = r5_n;
	if (r6_n > r5_n)
	{
		struct Eq_n * r0_n = r4_n->ptr0070;
		struct Eq_n * r1_n = r4_n->ptr0004;
		vListInsert(r0_n, &r1_n->dw0024);
	}
	else
	{
		vListInsert(r4_n->ptr006C, &r4_n->ptr0004->dw0024);
		if (r5_n < r4_n->dw0084)
			r4_n->dw0084 = r5_n;
	}
}

// 000008B4: Register ui32 xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register word32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
ui32 xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, word32 cpsr, int32 dwArg00, Eq_n * * dwArg04)
{
	struct Eq_n * r0_n = pvPortMalloc(r2 << 0x02, cpsr);
	if (r0_n == null)
		return ~0x00;
	ui32 r0_n;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0050 = r0_n;
		r0_n->b0065 = 0x00;
		prvInitialiseNewTask(r0, r1, r2, r3, dwArg00, dwArg04, r0_n, null);
		prvAddNewTaskToReadyList(r0_n, cpsr);
		r0_n = 0x01;
	}
	else
	{
		vPortFree();
		r0_n = ~0x00;
	}
	return r0_n;
}

// 0000091C: void xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register word32 cpsr)
void xTaskCreateRestricted(Eq_n * r0, Eq_n * * r1, word32 cpsr)
{
	if (r0->ptr0014 == null)
		return;
	struct Eq_n * r0_n = pvPortMalloc(0x68, cpsr);
	if (r0_n != null)
	{
		struct Eq_n * r1_n = r0->ptr0014;
		r0_n->b0065 = 0x01;
		word32 r3_n = r0->dw000C;
		ui32 r2_n = (word32) r0->w0008;
		int32 lr_n = r0->dw0010;
		r0_n->ptr0050 = r1_n;
		prvInitialiseNewTask(r0->dw0000, r0->dw0004, r2_n, r3_n, lr_n, r1, r0_n, (char *) &r0->ptr0014 + 0x04);
		prvAddNewTaskToReadyList(r0_n, cpsr);
	}
}

// 00000970: void vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1)
void vTaskAllocateMPURegions(word32 r0, Eq_n * r1)
{
	if (r0 == 0x00)
	{
		word32 r0_n = globals->ptr098C->dw0004;
		vPortStoreTaskMPUSettings(r0_n + 0x04, r1, null, 0x00);
	}
	else
		vPortStoreTaskMPUSettings(r0 + 0x04, r1, null, 0x00);
}

// 00000990: void vTaskStartScheduler(Register word32 cpsr)
void vTaskStartScheduler(word32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr09E0;
	word32 r0_n = xTaskCreate(globals->dw09E8, globals->dw09E4, 0x3B, 0x00, cpsr, 0x80000000, &r4_n->dw0084 + 0x01);
	if (r0_n != 0x01)
		return;
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	r4_n->dw0084 = ~0x00;
	r4_n->dw0074 = r0_n;
	r4_n->dw0080 = 0x00;
	xPortStartScheduler(cpsr);
}

// 000009EC: void vTaskEndScheduler(Register word32 cpsr)
void vTaskEndScheduler(word32 cpsr)
{
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	globals->ptr0A08->dw0074 = 0x00;
	vPortEndScheduler();
}

// 00000A0C: FlagGroup bool vTaskSuspendAll()
bool vTaskSuspendAll()
{
	struct Eq_n * r2_n = globals->ptr0A1C;
	word32 r3_n = r2_n->dw008C;
	r2_n->dw008C = r3_n + 0x01;
	return (bool) cond(r3_n + 0x01);
}

// 00000A20: void xTaskGetTickCount()
void xTaskGetTickCount()
{
}

// 00000A2C: void xTaskGetTickCountFromISR()
void xTaskGetTickCountFromISR()
{
}

// 00000A38: void uxTaskGetNumberOfTasks()
void uxTaskGetNumberOfTasks()
{
}

// 00000A44: void pcTaskGetName(Register word32 r0)
void pcTaskGetName(word32 r0)
{
	if (r0 == 0x00)
		;
}

// 00000A58: void xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register word32 r1, Register up32 r2, Register (ptr32 word32) r3, Register word32 cpsr)
void xTaskGenericNotify(Eq_n * r0, word32 r1, up32 r2, word32 * r3, word32 cpsr)
{
	ui32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04 && r2 >= 0x01)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			return;
		case 0x01:
			return;
		case 0x02:
l00000A86:
			if (r4_n == 0x02)
				goto l00000A92;
			r0->dw0060 = r1;
			break;
		case 0x03:
			r4_n = r0_n << 0x08;
			goto l00000A86;
		}
	}
	if (r4_n == 0x01)
	{
		struct Eq_n * r5_n = globals->ptr0B04;
		uxListRemove((char *) r0 + 0x0024);
		uint32 r0_n = r0->dw004C;
		r5_n->dw007C = r4_n << r0_n | r5_n->dw007C << 0x00;
		vListInsertEnd((char *) &r5_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		if (r0->dw004C > (r5_n->ptr0004)->dw004C)
		{
			*globals->ptr0B08 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return;
		}
	}
l00000A92:
	vPortExitCritical(cpsr);
}

// 00000B0C: void xTaskGenericNotifyFromISR(Register (ptr32 Eq_n) r0, Register word32 r1, Register up32 r2, Register (ptr32 word32) r3, Register word32 cpsr, Stack (ptr32 word32) dwArg00)
void xTaskGenericNotifyFromISR(Eq_n * r0, word32 r1, up32 r2, word32 * r3, word32 cpsr, word32 * dwArg00)
{
	struct Eq_n * r5_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_n = (uint32) (byte) r4_n;
	if (r2 <= 0x04 && r2 >= 0x01)
	{
		switch (r2 - 0x01)
		{
		case 0x00:
			return;
		case 0x01:
			return;
		case 0x02:
l00000B44:
			if (r4_n == 0x02)
				goto l00000B50;
			r0->dw0060 = r1;
			break;
		case 0x03:
			r4_n = r0 << 0x08;
			goto l00000B44;
		}
	}
	if (r4_n == 0x01)
	{
		struct Eq_n * r6_n = globals->ptr0BD0;
		if (r6_n->dw008C != 0x00)
			vListInsertEnd((char *) &r6_n->ptr0004 + 0x0054, (char *) r0 + 0x0038);
		else
		{
			uxListRemove((char *) r0 + 0x0024);
			uint32 r0_n = r0->dw004C;
			r6_n->dw007C = r4_n << r0_n | r6_n->dw007C;
			vListInsertEnd((char *) &r6_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		}
		if (r0->dw004C > (r6_n->ptr0004)->dw004C)
		{
			if (dwArg00 != null)
			{
				*dwArg00 = 0x01;
				__msr(cpsr, r5_n);
				return;
			}
			r6_n->dw0090 = 0x01;
l00000B50:
			__msr(cpsr, r5_n);
			return;
		}
	}
	goto l00000B50;
}

// 00000BD4: void xTaskNotifyWait(Register ui32 r0, Register ui32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register word32 cpsr)
void xTaskNotifyWait(ui32 r0, ui32 r1, ui32 * r2, up32 r3, word32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0C58;
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if ((word32) r4_n->ptr0004->b0064 != 0x02)
	{
		struct Eq_n * r1_n = r4_n->ptr0004;
		r1_n->dw0060 &= ~(r0 << 0x00);
		r4_n->ptr0004->b0064 = 0x01;
		if (r3 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r3);
			*globals->ptr0C5C = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if (r2 != null)
		*r2 = r4_n->ptr0004->dw0060;
	if ((word32) r4_n->ptr0004->b0064 != 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr0004;
		r3_n->dw0060 &= ~(r1 << 0x00);
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000C60: void vTaskNotifyGiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 word32) r1, Register word32 cpsr)
void vTaskNotifyGiveFromISR(Eq_n * r0, word32 * r1, word32 cpsr)
{
	struct Eq_n * r6_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	word32 r5_n = (word32) r0->b0064;
	r0->b0064 = 0x02;
	++r0->dw0060;
	uint32 r5_n = (uint32) (byte) r5_n;
	if (r5_n == 0x01)
	{
		struct Eq_n * r7_n = globals->ptr0CFC;
		if (r7_n->dw008C != 0x00)
			vListInsertEnd((char *) &r7_n->ptr0004 + 0x0054, (char *) r0 + 0x0038);
		else
		{
			uxListRemove((char *) r0 + 0x0024);
			uint32 r0_n = r0->dw004C;
			r7_n->dw007C = r5_n << r0_n | r7_n->dw007C;
			vListInsertEnd((char *) &r7_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r0 + 0x0024);
		}
		if (r0->dw004C > (r7_n->ptr0004)->dw004C)
		{
			if (r1 != null)
			{
				*r1 = 0x01;
				__msr(cpsr, r6_n);
				return;
			}
			r7_n->dw0090 = 0x01;
		}
	}
	__msr(cpsr, r6_n);
}

// 00000D00: void ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register word32 cpsr)
void ulTaskNotifyTake(word32 r0, up32 r1, word32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0D64;
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if (r4_n->ptr0004->dw0060 == 0x00)
	{
		r4_n->ptr0004->b0064 = 0x01;
		if (r1 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r1);
			*globals->ptr0D68 = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	word32 r5_n = r4_n->ptr0004->dw0060;
	if (r5_n != 0x00)
	{
		if (r0 == 0x00)
			r4_n->ptr0004->dw0060 = r5_n - 0x01;
		else
			r4_n->ptr0004->dw0060 = 0x00;
	}
	r4_n->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

// 00000D6C: Register word32 xTaskIncrementTick()
word32 xTaskIncrementTick()
{
	word32 r6_n;
	struct Eq_n * r4_n = globals->ptr0E64;
	if (r4_n->dw008C != 0x00)
	{
		++r4_n->dw0098;
		r6_n = 0x00;
		goto l00000E28;
	}
	up32 r7_n = r4_n->dw0080;
	r4_n->dw0080 = r7_n + 0x01;
	if (r7_n == 0x01)
	{
		struct Eq_n * r3_n = r4_n->ptr006C;
		r4_n->ptr006C = r4_n->ptr0070;
		r4_n->ptr0070 = r3_n;
		++r4_n->dw0094;
		if (r4_n->ptr006C->dw0000 != 0x00)
		{
			r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
			r6_n = 0x00;
			if (r7_n + 0x01 < r4_n->dw0084)
				goto l00000E14;
l00000DB2:
			r6_n = 0x00;
			word32 r8_n = globals->dw0E68;
			while (r4_n->ptr006C->dw0000 != 0x00)
			{
				struct Eq_n * r5_n = r4_n->ptr006C->ptr000C->ptr000C;
				up32 r3_n = r5_n->dw0024;
				if (r7_n + 0x01 < r3_n)
				{
					r4_n->dw0084 = r3_n;
					goto l00000E14;
				}
				uxListRemove(&r5_n->dw0024);
				if (r5_n->dw0048 != 0x00)
					uxListRemove(&r5_n->dw0024 + 0x05);
				uint32 r0_n = r5_n->dw004C;
				r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
				vListInsertEnd(r8_n + r0_n * 0x14, &r5_n->dw0024);
				if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
					r6_n = 0x01;
			}
			r4_n->dw0084 = ~0x00;
l00000E14:
			if (*((char *) &(r4_n + ((r4_n->ptr0004)->dw004C * 0x14) / 0x009C)->ptr0004 + 0x04) >= 0x02)
				r6_n = 0x01;
l00000E28:
			if (r4_n->dw0090 != 0x00)
				r6_n = 0x01;
			return r6_n;
		}
		r4_n->dw0084 = ~0x00;
	}
	r6_n = 0x00;
	if (r7_n + 0x01 < r4_n->dw0084)
		goto l00000E14;
	goto l00000DB2;
}

// 00000E6C: Register word32 xTaskResumeAll(Register word32 cpsr)
word32 xTaskResumeAll(word32 cpsr)
{
	struct Eq_n * r4_n = globals->ptr0F40;
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	--r4_n->ptr008C;
	struct Eq_n * r5_n = r4_n->ptr008C;
	if (r5_n == null && r4_n->dw0000 != 0x00)
	{
		while (r4_n->dw0058 != 0x00)
		{
			r5_n = r4_n->ptr0064->ptr000C;
			uxListRemove((char *) r5_n + 0x0038);
			uxListRemove((char *) r5_n + 0x0024);
			uint32 r0_n = r5_n->dw004C;
			r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
			vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14, (char *) r5_n + 0x0024);
			if (r5_n->dw004C >= (r4_n->ptr0004)->dw004C)
				r4_n->dw0090 = 0x01;
		}
		if (r5_n != null)
		{
			if (r4_n->ptr006C->dw0000 == 0x00)
				r4_n->dw0084 = ~0x00;
			else
				r4_n->dw0084 = r4_n->ptr006C->ptr000C->ptr000C->dw0024;
		}
		word32 r5_n = r4_n->dw0098;
		if (r5_n != 0x00)
		{
			do
			{
				if (xTaskIncrementTick() != 0x00)
					r4_n->dw0090 = 0x01;
				--r5_n;
			} while (r5_n != 0x00);
			r4_n->dw0098 = r5_n;
		}
		if (r4_n->dw0090 != 0x00)
		{
			*globals->ptr0F44 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return 0x01;
		}
	}
	vPortExitCritical(cpsr);
	return 0x00;
}

// 00000F48: void vTaskDelay(Register up32 r0, Register word32 cpsr)
void vTaskDelay(up32 r0, word32 cpsr)
{
	if (r0 != 0x00)
	{
		struct Eq_n * r2_n = globals->ptr0F7C;
		++r2_n->dw008C;
		prvAddCurrentTaskToDelayedList.isra.0(r0);
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
	}
	*globals->ptr0F78 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000F80: void vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register word32 cpsr)
void vTaskDelayUntil(up32 * r0, word32 r1, word32 cpsr)
{
	struct Eq_n * r2_n = globals->ptr0FD4;
	up32 r3_n = *r0;
	++r2_n->dw008C;
	up32 r2_n = r2_n->dw0080;
	up32 r1_n = r1 + r3_n;
	if (r2_n < r3_n)
	{
		if (r3_n <= r1_n)
			goto l00000F9E;
	}
	else if (r3_n > r1_n)
		goto l00000FC0;
	if (r2_n >= r1_n)
	{
l00000F9E:
		*r0 = r1_n;
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
		goto l00000FA6;
	}
l00000FC0:
	*r0 = r1_n;
	prvAddCurrentTaskToDelayedList.isra.0(r1_n - r2_n);
	if (xTaskResumeAll(cpsr) != 0x00)
		return;
l00000FA6:
	*globals->ptr0FD8 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

// 00000FDC: void vTaskPlaceOnEventList(Register (ptr32 Eq_n) r0, Register up32 r1)
void vTaskPlaceOnEventList(Eq_n * r0, up32 r1)
{
	vListInsert(r0, globals->ptr0FF4->dw0004 + 0x38);
	prvAddCurrentTaskToDelayedList.isra.0(r1);
}

// 00000FF8: void vTaskPlaceOnUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1, Register up32 r2)
void vTaskPlaceOnUnorderedEventList(Eq_n * r0, ui32 r1, up32 r2)
{
	struct Eq_n * r3_n = globals->ptr1018;
	struct Eq_n * r3_n = r3_n->ptr0004;
	r3_n->ptr0004->dw0038 = r1 | 0x80000000;
	vListInsertEnd(r0, &r3_n->dw0038);
	prvAddCurrentTaskToDelayedList.isra.0(r2);
}

// 0000101C: void xTaskRemoveFromEventList(Register (ptr32 Eq_n) r0)
void xTaskRemoveFromEventList(Eq_n * r0)
{
	struct Eq_n * r0_n;
	struct Eq_n * r4_n = globals->ptr107C;
	struct Eq_n * r5_n = r0->ptr000C->ptr000C;
	uxListRemove((char *) r5_n + 0x0038);
	if (r4_n->dw008C == 0x00)
	{
		uxListRemove((char *) r5_n + 0x0024);
		uint32 r0_n = r5_n->dw004C;
		r4_n->dw007C = 0x01 << r0_n | r4_n->dw007C;
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 0x04 + r0_n * 0x14);
		vListInsertEnd(r0_n, (char *) r5_n + 0x0024);
	}
	else
	{
		vListInsertEnd((char *) &r4_n->ptr0004 + 0x0054, (char *) r5_n + 0x0038);
		r0_n = (struct Eq_n *) ((char *) &r4_n->ptr0004 + 0x0054);
	}
	if (r5_n->dw004C > (r4_n->ptr0004)->dw004C)
		r0_n = &globals->t0001;
	r4_n->ptr0090 = r0_n;
}

// 00001080: void xTaskRemoveFromUnorderedEventList(Register (ptr32 Eq_n) r0, Register ui32 r1)
void xTaskRemoveFromUnorderedEventList(Eq_n * r0, ui32 r1)
{
	struct Eq_n * r6_n = r0->ptr000C;
	r0->dw0000 = r1 | 0x80000000;
	uxListRemove(r0);
	struct Eq_n * r4_n = globals->ptr10D4;
	uxListRemove((char *) r6_n + 0x0024);
	uint32 r3_n = r6_n->dw004C;
	r4_n->dw007C = 0x01 << r3_n | r4_n->dw007C << 0x00;
	vListInsertEnd((char *) &r4_n->ptr0004 + 0x04 + r3_n * 0x14, (char *) r6_n + 0x0024);
	r6_n->dw004C <= (r4_n->ptr0004)->dw004C;
	r4_n->dw0090 = 0x01;
}

// 000010D8: void vTaskSwitchContext()
void vTaskSwitchContext()
{
	struct Eq_n * r2_n = globals->ptr111C;
	word32 r3_n = r2_n->dw008C;
	if (r3_n != 0x00)
		r2_n->dw0090 = 0x01;
	else
	{
		struct Eq_n * r1_n;
		r2_n->dw0090 = r3_n;
		struct Eq_n * r0_n = r2_n + ((0x1F - (uint32) ((byte) __clz(r2_n->dw007C))) * 0x14) / 0x0094;
		struct Eq_n * r1_n = r0_n->ptr000C->ptr0004;
		r0_n->ptr000C = r1_n;
		r1_n = r1_n;
		if (r1_n == (char *) (&r0_n->ptr000C) + 0x04)
			r1_n = r1_n->ptr0004;
		word32 r3_n = r1_n->dw000C;
		if (r1_n == (char *) (&r0_n->ptr000C) + 0x04)
			r0_n->ptr000C = r1_n;
		r2_n->dw0004 = r3_n;
	}
}

// 00001120: Register word32 uxTaskResetEventItemValue()
word32 uxTaskResetEventItemValue()
{
	struct Eq_n * r3_n = globals->ptr1134;
	word32 r0_n = r3_n->ptr0004->dw0038;
	r3_n->ptr0004->dw0038 = 0x02 - (r3_n->ptr0004)->dw004C;
	return r0_n;
}

// 00001138: Register word32 xTaskGetCurrentTaskHandle()
word32 xTaskGetCurrentTaskHandle()
{
	return globals->ptr1140->dw0004;
}

// 00001144: void vTaskSetTimeOutState(Register (ptr32 Eq_n) r0)
void vTaskSetTimeOutState(Eq_n * r0)
{
	struct Eq_n * r3_n = globals->ptr1154;
	word32 r3_n = r3_n->dw0080;
	r0->dw0000 = r3_n->dw0094;
	r0->dw0004 = r3_n;
}

// 00001158: Register (ptr32 Eq_n) xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register word32 cpsr)
Eq_n * xTaskCheckForTimeOut(Eq_n * r0, up32 * r1, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	struct Eq_n * r3_n = globals->ptr11A8;
	up32 r5_n = r3_n->dw0080;
	up32 r0_n = r0->dw0004;
	if (r0->dw0000 == r3_n->dw0094 || r5_n < r0_n)
	{
		up32 r2_n = *r1;
		if (r5_n - r0_n < r2_n)
		{
			word32 r1_n = r3_n->dw0094;
			up32 r3_n = r3_n->dw0080;
			*r1 = r2_n - r5_n + r0_n;
			r0->dw0000 = r1_n;
			r0->dw0004 = r3_n;
			vPortExitCritical(cpsr);
			return null;
		}
	}
	vPortExitCritical(cpsr);
	return &globals->t0001;
}

// 000011AC: void vTaskMissedYield()
void vTaskMissedYield()
{
	globals->ptr11B8->dw0090 = 0x01;
}

// 000011BC: void vTaskPriorityInherit(Register (ptr32 Eq_n) r0)
void vTaskPriorityInherit(Eq_n * r0)
{
	if (r0 == null)
		return;
	struct Eq_n * r4_n = globals->ptr1248;
	uint32 r3_n = r0->dw004C;
	if (r3_n >= (r4_n->ptr0004)->dw004C)
		return;
	if (r0->dw0038 >= 0x00)
		r0->dw0038 = 0x02 - (r4_n->ptr0004)->dw004C;
	word32 r5_n = globals->dw124C;
	if (r0->dw0034 == r5_n + r3_n * 0x14)
	{
		if (uxListRemove(&r0->dw000C + 0x06) == 0x00)
		{
			uint32 r2_n = r0->dw004C;
			if (*((char *) &(r4_n + (r2_n * 0x14) / 0x0080)->ptr0004 + 0x04) == 0x00)
				r4_n->dw007C &= ~(0x01 << r2_n << 0x00);
		}
		uint32 r2_n = r4_n->ptr0004->dw004C;
		ui32 r3_n = 0x01 << r2_n | r4_n->dw007C << 0x00;
		r0->dw004C = r2_n;
		r4_n->dw007C = r3_n;
		struct Eq_n * r0_n = r5_n + r2_n * 0x14;
		vListInsertEnd(r0_n, &r0->dw000C + 0x06);
	}
	else
		r0->dw004C = r4_n->ptr0004->dw004C;
}

// 00001250: Register (ptr32 Eq_n) xTaskPriorityDisinherit(Register (ptr32 Eq_n) r0)
Eq_n * xTaskPriorityDisinherit(Eq_n * r0)
{
	if (r0 == null)
		return null;
	uint32 r1_n = r0->dw004C;
	word32 r3_n = r0->dw005C;
	uint32 r2_n = r0->dw0058;
	r0->dw005C = r3_n - 0x01;
	if (r1_n == r2_n || r3_n != 0x01)
		return null;
	struct Eq_n * r2_n;
	if (uxListRemove(&r0->dw000C + 0x06) == 0x00)
	{
		uint32 r1_n = r0->dw004C;
		r2_n = globals->ptr12CC;
		if (*((char *) (r2_n + (r1_n * 0x14) / 0x0080) + 0x08) == 0x00)
			r2_n->dw007C &= ~(0x01 << r1_n << 0x00);
	}
	else
		r2_n = globals->ptr12CC;
	uint32 r3_n = r0->dw0058;
	ui32 lr_n = r2_n->dw007C;
	word32 r0_n = globals->dw12D0;
	r0->dw004C = r3_n;
	r0->dw0038 = 0x02 - r3_n;
	r2_n->dw007C = 0x01 << r3_n | lr_n << 0x00;
	vListInsertEnd(r0_n + r3_n * 0x14, &r0->dw000C + 0x06);
	return &globals->t0001;
}

// 000012D4: Register (ptr32 Eq_n) pvTaskIncrementMutexHeldCount()
Eq_n * pvTaskIncrementMutexHeldCount()
{
	struct Eq_n * r3_n = globals->ptr12E8;
	if (r3_n->ptr0004 != null)
	{
		struct Eq_n * r1_n = r3_n->ptr0004;
		++r1_n->dw005C;
	}
	return r3_n->ptr0004;
}

// 000012F0: void prvRestoreContextOfFirstTask(Register word32 cpsr)
void prvRestoreContextOfFirstTask(word32 cpsr)
{
	__msr(cpsr, **globals->ptr1724);
	struct Eq_n * r1_n = *globals->ptr1330;
	struct Eq_n ** r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 0x0024);
	__msr(cpsr, null);
}

// 00001334: void prvSVCHandler(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void prvSVCHandler(Eq_n * r0, word32 cpsr)
{
	up32 r3_n = (word32) *(r0->ptr0018 - 0x02);
	if (r3_n == 0x01)
	{
		*globals->ptr1378 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	else if (r3_n < 0x01)
	{
		ui32 * r2_n = globals->ptr1374;
		*r2_n |= 0xBE000000;
		prvRestoreContextOfFirstTask(cpsr);
	}
	else
	{
		if (r3_n != 0x02)
			return;
		__msr(cpsr, __mrs(cpsr) & ~0x01);
	}
}

// 0000137C: Register (ptr32 Eq_n) pxPortInitialiseStack(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 r2, Register int32 r3)
Eq_n * pxPortInitialiseStack(Eq_n * r0, ui32 r1, word32 r2, int32 r3)
{
	int32 r3_n;
	r3_n = r3;
	if (r3 == 0x01)
		r3_n = 0x02;
	if (r3 != 0x01)
		r3_n = 0x03;
	*(r0 - 0x0020) = r2;
	r0->dwFFFFFFF8 = r1 & ~0x01;
	r0->dwFFFFFFFC = 0x01000000;
	*(r0 - 0x0C) = 0x00;
	*(r0 - 0x0044) = r3_n;
	return r0 - 0x44;
}

// 000013B0: void xPortStartScheduler(Register word32 cpsr)
void xPortStartScheduler(word32 cpsr)
{
	ui32 * r3_n = globals->ptr14E8;
	word32 * r1_n = globals->ptr14EC;
	*r3_n |= 0x00FF0000;
	*r3_n |= 0xFF000000;
	if (*r1_n == 0x0800)
	{
		ui32 r2_n;
		ui32 r0_n = globals->dw14FC;
		uint32 r1_n = globals->dw1500 - r0_n;
		*globals->ptr1504 = r0_n | 0x10;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1508 | r2_n << 0x01;
					goto l0000142C;
				}
			}
			r2_n = globals->dw1538;
		}
		else
			r2_n = globals->dw1548;
l0000142C:
		ui32 r2_n;
		uint32 r1_n = globals->dw150C - r0_n;
		ui32 * r3_n = globals->ptr1504;
		*globals->ptr1510 = r2_n;
		*r3_n = r0_n | 0x11;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1514 | r2_n << 0x01;
					goto l0000145A;
				}
			}
			r2_n = globals->dw153C;
		}
		else
			r2_n = globals->dw1544;
l0000145A:
		ui32 r0_n;
		ui32 r3_n = globals->dw1518;
		ui32 * r0_n = globals->ptr1504;
		uint32 r1_n = globals->dw151C - r3_n;
		*globals->ptr1510 = r2_n;
		*r0_n = r3_n | 0x12;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r0_n = globals->dw1520 | r2_n << 0x01;
					goto l0000148A;
				}
			}
			r0_n = globals->dw1540;
		}
		else
			r0_n = globals->dw154C;
l0000148A:
		ui32 * r4_n = globals->ptr1504;
		ui32 r5_n = globals->dw1524;
		uint32 r1_n = globals->dw1528;
		*globals->ptr1510 = r0_n;
		*r4_n = r5_n;
		ui32 r3_n = 0x05;
		uint32 r2_n = 0x40;
		do
		{
			ui32 r3_n;
			++r3_n;
			r2_n <<= 0x01;
			if (r3_n == 0x1F)
			{
				r3_n = globals->dw1534;
				goto l000014AE;
			}
		} while (r2_n <= r1_n);
		r3_n = globals->dw152C | r3_n << 0x01;
l000014AE:
		ui32 * r2_n = globals->ptr1510;
		ui32 * r1_n = globals->ptr1530;
		*r2_n = r3_n;
		*r1_n |= 0x00010000;
		*(r2_n - 0x0C) |= 0x05;
	}
	word32 * r2_n = globals->ptr14F4;
	word32 * r3_n = globals->ptr14F8;
	*globals->ptr14F0 = 19999;
	*r2_n = 0x07;
	*r3_n = 0x00;
	__msr(cpsr, **globals->ptr1724);
	__cps_id();
	__cps_id();
	__dsb_sy();
	__isb_sy();
	__syscall(0x00);
}

// 00001550: void vPortEndScheduler()
void vPortEndScheduler()
{
}

// 00001554: void vPortStoreTaskMPUSettings(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register ui32 r3)
void vPortStoreTaskMPUSettings(Eq_n * r0, Eq_n * r1, Eq_n * r2, ui32 r3)
{
	if (r1 == null)
	{
		ui32 r2_n;
		ui32 r3_n = globals->dw1668;
		uint32 r1_n = globals->dw166C - r3_n;
		r0->dw0000 = r3_n | 0x14;
		if (r1_n > 0x20)
		{
			uint32 r3_n = 0x40;
			ui32 r2_n;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r3_n >= r1_n)
				{
					r2_n = globals->dw1660 | r2_n << 0x01;
					goto l00001608;
				}
			}
			r2_n = globals->dw1664;
		}
		else
			r2_n = globals->dw1680;
l00001608:
		ui32 r2_n;
		ui32 r3_n = globals->dw1670;
		uint32 r1_n = globals->dw1674 - r3_n;
		r0->dw0004 = r2_n;
		r0[0x01] = (struct Eq_n) (r3_n | 0x15);
		if (r1_n > 0x20)
		{
			ui32 r2_n;
			uint32 r3_n = 0x40;
			for (r2_n = 0x05; r2_n != 0x1F; ++r2_n)
			{
				r3_n <<= 0x01;
				if (r1_n <= r3_n)
				{
					r2_n = globals->dw1678 | r2_n << 0x01;
					goto l00001634;
				}
			}
			r2_n = globals->dw167C;
		}
		else
			r2_n = globals->dw1684;
l00001634:
		r0[0x02] = (struct Eq_n) 22;
		r0->dw000C = r2_n;
		r0->dw0014 = 0x00;
		r0->dw001C = 0x00;
		r0[0x03] = (struct Eq_n) 0x17;
	}
	else
	{
		if (r3 != 0x00)
		{
			ui32 r4_n;
			r0->dw0000 = r2 | 0x14;
			if (r3 << 0x02 > 0x20)
			{
				uint32 r2_n = 0x40;
				ui32 r4_n;
				for (r4_n = 0x05; r4_n != 0x1F; ++r4_n)
				{
					r2_n <<= 0x01;
					if (r3 << 0x02 <= r2_n)
					{
						r4_n = globals->dw1660 | r4_n << 0x01;
						goto l000015D6;
					}
				}
				r4_n = globals->dw1664;
			}
			else
				r4_n = globals->dw1680;
l000015D6:
			r0->dw0004 = r4_n;
		}
		ui32 r5_n;
		for (r5_n = 0x05; r5_n != 0x08; ++r5_n)
		{
			uint32 r4_n = r1->dw0004;
			if (r4_n != 0x00)
			{
				ui32 r3_n;
				r0[0x01] = (struct Eq_n) (r1->dw0000 | (r5_n | 0x10));
				if (r4_n > 0x20)
				{
					uint32 r2_n = 0x40;
					ui32 r3_n;
					for (r3_n = 0x05; r3_n != 0x1F; ++r3_n)
					{
						r2_n <<= 0x01;
						if (r4_n <= r2_n)
						{
							r3_n = r3_n << 0x01;
							goto l00001586;
						}
					}
					r3_n = 0x3E;
				}
				else
					r3_n = 0x08;
l00001586:
				r0->dw000C = r3_n | (r1->dw0008 | 0x01);
			}
			else
			{
				r0->dw000C = r4_n;
				r0[0x01] = (struct Eq_n) (r5_n | 0x10);
			}
			++r1;
			++r0;
		}
	}
}

// 00001688: void xPortPendSVHandler(Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 r9, Register word32 r10, Register word32 fp, Register word32 cpsr)
void xPortPendSVHandler(word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 r9, word32 r10, word32 fp, word32 cpsr)
{
	struct Eq_n * r0_n = __mrs(cpsr);
	struct Eq_n ** r3_n = globals->ptr16E0;
	struct Eq_n * r2_n = *r3_n;
	r0_n->ptrFFFFFFDC = __mrs(cpsr);
	r0_n->dwFFFFFFE0 = r4;
	r0_n->dwFFFFFFE4 = r5;
	r0_n->dwFFFFFFE8 = r6;
	r0_n->dwFFFFFFEC = r7;
	r0_n->dwFFFFFFF0 = r8;
	r0_n->dwFFFFFFF4 = r9;
	r0_n->dwFFFFFFF8 = r10;
	r0_n->dwFFFFFFFC = fp;
	r2_n->ptr0000 = r0_n - 0x0024;
	__msr(cpsr, &globals->t00BF);
	vTaskSwitchContext();
	__msr(cpsr, null);
	struct Eq_n * r1_n = *r3_n;
	struct Eq_n ** r0_n = r1_n->ptr0000;
	struct Eq_n * r2_n = globals->ptr1728;
	word32 r5_n = r1_n->dw0008;
	word32 r6_n = r1_n->dw000C;
	word32 r7_n = r1_n->dw0010;
	word32 r8_n = r1_n->dw0014;
	word32 r9_n = r1_n->dw0018;
	word32 r10_n = r1_n->dw001C;
	word32 fp_n = r1_n->dw0020;
	r2_n->dw0000 = r1_n->dw0004;
	r2_n->dw0004 = r5_n;
	r2_n->dw0008 = r6_n;
	r2_n->dw000C = r7_n;
	r2_n->dw0010 = r8_n;
	r2_n->dw0014 = r9_n;
	r2_n->dw0018 = r10_n;
	r2_n->dw001C = fp_n;
	__msr(cpsr, *r0_n);
	__msr(cpsr, (char *) r0_n + 0x0024);
}

// 000016E4: void xPortSysTickHandler(Register word32 cpsr)
void xPortSysTickHandler(word32 cpsr)
{
	struct Eq_n * r4_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	if (xTaskIncrementTick() != 0x00)
		*globals->ptr1710 = 0x10000000;
	__msr(cpsr, r4_n);
}

// 00001714: void vPortSVCHandler(Register ui32 lr, Register word32 cpsr)
void vPortSVCHandler(ui32 lr, word32 cpsr)
{
	if ((lr & 0x04) == 0x00)
		__mrs(cpsr);
	struct Eq_n * r0_n = __mrs(cpsr);
	prvSVCHandler(r0_n, cpsr);
}

// 0000172C: Register ui32 pvPortMalloc(Register ui32 r0, Register word32 cpsr)
ui32 pvPortMalloc(ui32 r0, word32 cpsr)
{
	ui32 r4_n = r0;
	if (r0 << 0x001D != 0x00)
		r4_n = r0 & ~0x07;
	vTaskSuspendAll();
	struct Eq_n * r3_n = globals->ptr177C;
	word32 r4_n = r4_n + 0x08;
	if (r3_n->dw0000 == 0x00)
		Mem49[r3_n + 0x00:word32] = r3_n + 0x0C & ~0x07;
	up32 r2_n = r3_n->dw05C0;
	up32 r4_n = r4_n + r2_n;
	if (r4_n > 0x05B3 || r2_n >= r4_n)
	{
		xTaskResumeAll(cpsr);
		return 0x00;
	}
	else
	{
		ui32 r1_n = r3_n->dw0000;
		r3_n->dw05C0 = r4_n;
		xTaskResumeAll(cpsr);
		return r1_n + r2_n;
	}
}

// 00001780: void vPortFree()
void vPortFree()
{
}

// 00001784: void vPortInitialiseBlocks()
void vPortInitialiseBlocks()
{
	globals->ptr1790->dw05C0 = 0x00;
}

// 00001794: void xPortGetFreeHeapSize()
void xPortGetFreeHeapSize()
{
}

// 000017A8: void xEventGroupCreate(Register word32 cpsr)
void xEventGroupCreate(word32 cpsr)
{
	struct Eq_n * r0_n = pvPortMalloc(0x18, cpsr);
	if (r0_n != null)
	{
		r0_n->ptr0000 = null;
		vListInitialise(&r0_n->dw0004);
	}
}

// 000017C4: void xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register word32 cpsr, Stack up32 dwArg00)
void xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, word32 cpsr, up32 dwArg00)
{
	bool C_n = vTaskSuspendAll();
	ui32 r5_n = r1;
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r4_n = r4_n + r1 + C_n;
		if (r4_n != 0x00)
		{
l000017DC:
			if (r2 != 0x00)
				*r0 = r4_n & ~(r1 << 0x00);
l000017E8:
			xTaskResumeAll(cpsr);
			return;
		}
	}
	else if ((r1 & ~(r4_n << 0x00)) == 0x00)
		goto l000017DC;
	if (dwArg00 == 0x00)
		goto l000017E8;
	ui32 r1_n = 0x01000000;
	if (r3 != 0x00)
		r1_n = 0x05000000;
	vTaskPlaceOnUnorderedEventList(r0 + 0x01, r1_n | r1, dwArg00);
	if (xTaskResumeAll(cpsr) == 0x00)
	{
		*globals->ptr1870 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	if (uxTaskResetEventItemValue() << 0x06 < 0x00)
		return;
	word32 r0_n;
	bool C_n = vPortEnterCritical(cpsr, out r0_n);
	ui32 r4_n = *r0;
	if (r3 == 0x00)
	{
		r5_n = r1 + r4_n + C_n;
		if (r5_n == 0x00)
			goto l0000185C;
	}
	else if ((r1 & ~(r4_n << 0x00)) != 0x00)
		goto l0000185C;
	if (r2 != 0x00)
		*r0 = r4_n & ~(r5_n << 0x00);
l0000185C:
	vPortExitCritical(cpsr);
}

// 00001874: void xEventGroupClearBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 cpsr)
void xEventGroupClearBits(ui32 * r0, ui32 r1, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	*r0 &= ~(r1 << 0x00);
	vPortExitCritical(cpsr);
}

// 00001890: void xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
void xEventGroupSetBits(Eq_n * r0, ui32 r1, word32 cpsr)
{
	ui32 r7_n;
	vTaskSuspendAll();
	struct Eq_n * r0_n = r0->ptr0010;
	ui32 r1_n = r0->dw0000 | r1;
	r0->dw0000 = r1_n;
	if (&r0->dw0000 + 0x03 != r0_n)
	{
		ui32 r7_n = 0x00;
		do
		{
			ui32 r3_n = r0_n->dw0000;
			struct Eq_n * r4_n = r0_n->ptr0004;
			ui32 r2_n = r3_n & ~0xFF000000;
			if ((r3_n & 0x04000000) == 0x00)
			{
				r2_n = r2_n + r1_n + ((r3_n & 0x04000000) < 0x00);
				if (r2_n != 0x00)
				{
l000018B2:
					if (r3_n << 0x07 < 0x00)
						r7_n |= r2_n;
					xTaskRemoveFromUnorderedEventList(r0_n, r1_n | 0x02000000);
					r1_n = r0->dw0000;
				}
				r0_n = r4_n;
				if (&r0->dw0000 + 0x03 != r4_n)
					continue;
				break;
			}
			if ((r2_n & ~(r1_n << 0x00)) == 0x00)
				goto l000018B2;
			r0_n = r4_n;
		} while (&r0->dw0000 + 0x03 != r4_n);
		r7_n = ~r7_n;
	}
	else
		r7_n = ~0x00;
	r0->dw0000 = r1_n & r7_n;
	xTaskResumeAll(cpsr);
}

// 000018F8: void xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register word32 cpsr)
void xEventGroupSync(Eq_n * r0, ui32 r1, ui32 r2, up32 r3, word32 cpsr)
{
	vTaskSuspendAll();
	ui32 r4_n = r0->dw0000 | r1;
	xEventGroupSetBits(r0, r1, cpsr);
	ui32 r6_n = r2;
	if ((r2 & ~(r4_n << 0x00)) != 0x00)
	{
		if (r3 != 0x00)
		{
			vTaskPlaceOnUnorderedEventList(&r0->dw0000 + 0x01, r2 | 0x05000000, r3);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*globals->ptr1984 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
			if (uxTaskResetEventItemValue() << 0x06 >= 0x00)
			{
				word32 r0_n;
				vPortEnterCritical(cpsr, out r0_n);
				ui32 r4_n = r0->dw0000;
				if ((r2 & ~(r4_n << 0x00)) == 0x00)
					r6_n = r4_n & ~(r2 << 0x00);
				r0->dw0000 = r6_n;
				vPortExitCritical(cpsr);
			}
			return;
		}
	}
	else
		r0->dw0000 &= ~(r2 << 0x00);
	xTaskResumeAll(cpsr);
}

// 00001988: void xEventGroupGetBitsFromISR(Register word32 r0, Register word32 cpsr)
void xEventGroupGetBitsFromISR(word32 r0, word32 cpsr)
{
	struct Eq_n * r3_n = __mrs(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	__msr(cpsr, r3_n);
}

// 000019A4: void vEventGroupDelete(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void vEventGroupDelete(Eq_n * r0, word32 cpsr)
{
	vTaskSuspendAll();
	while (r0->dw0004 != 0x00)
		xTaskRemoveFromUnorderedEventList(r0->ptr0010, 0x02000000);
	vPortFree();
	xTaskResumeAll(cpsr);
}

// 000019D0: void vEventGroupSetBitsCallback(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
void vEventGroupSetBitsCallback(Eq_n * r0, ui32 r1, word32 cpsr)
{
	xEventGroupSetBits(r0, r1, cpsr);
}

// 000019D4: void vEventGroupClearBitsCallback(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 cpsr)
void vEventGroupClearBitsCallback(ui32 * r0, ui32 r1, word32 cpsr)
{
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	*r0 &= ~(r1 << 0x00);
	vPortExitCritical(cpsr);
}

// 00008000: void NmiSR()
void NmiSR()
{
	while (true)
		;
}

// 00008004: void FaultISR()
void FaultISR()
{
	while (true)
		;
}

// 00008008: void ResetISR(Register word32 cpsr)
void ResetISR(word32 cpsr)
{
	word32 * r3_n = globals->ptr802C;
	word32 * r0_n = globals->ptr8030;
	if (r3_n < r0_n)
	{
		word32 * r2_n = r3_n + ((r0_n + ~r3_n & ~0x03) + 0x04);
		do
		{
			*r3_n = 0x00;
			++r3_n;
		} while (r3_n != r2_n);
	}
	Main(cpsr);
}

// 00008034: void raise()
void raise()
{
	while (true)
		;
}

// 00008038: void vPrintTask(Register word32 cpsr)
void vPrintTask(word32 cpsr)
{
	ui32 r4_n = 0x00;
	struct Eq_n ** r5_n = globals->ptr8064;
	while (true)
	{
		MPU_xQueueGenericReceive(*r5_n, fp - 0x0014, ~0x00, 0x00, cpsr);
		OSRAMClear();
		++r4_n;
		OSRAMStringDraw(dwLoc14, r4_n & 0x3F, r4_n & 0x01);
	}
}

// 00008068: void vCheckTask(Register word32 cpsr)
void vCheckTask(word32 cpsr)
{
	MPU_xTaskGetTickCount(cpsr);
	struct Eq_n ** r5_n = globals->ptr809C;
	while (true)
	{
		MPU_vTaskDelayUntil(fp - 0x0018, 5000, cpsr);
		MPU_xQueueGenericSend(*r5_n, fp - 0x0014, ~0x00, 0x00, cpsr);
	}
}

// 000080A0: void Main(Register word32 cpsr)
void Main(word32 cpsr)
{
	MPU_xQueueGenericCreate(&globals->t0003, 0x04, cpsr);
	*globals->ptr80F0 = 0x03;
	OSRAMInit(0x00);
	MPU_xTaskCreate(globals->dw80F8, globals->dw80F4, 0x3B, 0x00, cpsr, 0x03, null);
	MPU_xTaskCreate(globals->dw8100, globals->dw80FC, 0x3B, 0x00, cpsr, 0x02, null);
	vTaskStartScheduler(cpsr);
	OSRAMStringDraw(globals->ptr8104, 0x00, 0x00);
	while (true)
		;
}

// 00008108: void vUART_ISR(Register word32 cpsr)
void vUART_ISR(word32 cpsr)
{
	struct Eq_n * r5_n = globals->ptr8174;
	struct Eq_n * r0_n = UARTIntStatus(r5_n, 0x01);
	UARTIntClear(r5_n, r0_n);
	if (r0_n << 0x001B < 0x00 && *globals->ptr8178 << 0x0019 < 0x00)
		xQueueGenericSendFromISR(fp - 0x15, r0_n, fp - 0x0014, 0x00, cpsr);
	if (r0_n << 0x001A < 0x00)
	{
		byte * r2_n = globals->ptr817C;
		up32 r3_n = (word32) *r2_n;
		if (r3_n <= 122)
		{
			ui32 r1_n = *globals->ptr8178;
			struct Eq_n * r1_n = r1_n << 0x001A;
			if (r1_n << 0x001A >= 0x00)
				r1_n = globals->ptr8174;
			r1_n->dw0000 = r3_n;
			*r2_n = (byte) (r3_n + 0x01);
		}
	}
	if (0x00 != 0x00)
		*globals->ptr8180 = 0x10000000;
}

// 00008184: void vSetErrorLED(Register word32 cpsr)
void vSetErrorLED(word32 cpsr)
{
	vParTestSetLED(0x07, 0x01, cpsr);
}

// 0000818C: void prvSetAndCheckRegisters()
void prvSetAndCheckRegisters()
{
	if (true && (true && (true && (true && (true && (true && (true && (true && (true && (true && (true && (true && true))))))))))))
		;
}

// 00008210: void vApplicationIdleHook(Register word32 cpsr)
void vApplicationIdleHook(word32 cpsr)
{
	while (true)
	{
		vCoRoutineSchedule(cpsr);
		prvSetAndCheckRegisters();
	}
}

// 00008220: void PDCInit()
void PDCInit()
{
	SysCtlPeripheralEnable(globals->dw828C);
	SysCtlPeripheralEnable(globals->dw8290);
	GPIODirModeSet((struct Eq_n *) 0x40004000, 0x34, 0x02);
	GPIODirModeSet((struct Eq_n *) 0x40004000, 0x08, 0x01);
	GPIOPadConfigSet((struct Eq_n *) 0x40004000, 0x04, 0x02, 0x0A);
	struct Eq_n * r5_n = globals->ptr8294;
	SSIConfig(r5_n, 0x00, 0x00, globals->dw8298, 0x08);
	SSIEnable(r5_n);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x00);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x08);
}

// 0000829C: void PDCWrite(Register ui32 r0, Register ui32 r1)
void PDCWrite(ui32 r0, ui32 r1)
{
	struct Eq_n * r4_n = globals->ptr82CC;
	SSIDataPut(r4_n, r0 & 0x0F);
	SSIDataPut(r4_n, r1);
	SSIDataGet(r4_n, fp - 0x0014);
	SSIDataGet(r4_n, fp - 0x0014);
}

// 000082D0: void vListInitialise(Register (ptr32 Eq_n) r0)
void vListInitialise(Eq_n * r0)
{
	r0->dw0008 = ~0x00;
	r0->dw0000 = 0x00;
	r0->ptr0004 = (word32 *) &r0->dw0008;
	r0->ptr000C = (word32 *) &r0->dw0008;
	r0->ptr0010 = (word32 *) &r0->dw0008;
}

// 000082E8: void vListInitialiseItem(Register (ptr32 Eq_n) r0)
void vListInitialiseItem(Eq_n * r0)
{
	r0->dw0010 = 0x00;
}

// 000082F0: void vListInsertEnd(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
void vListInsertEnd(Eq_n * r0, Eq_n * r1)
{
	struct Eq_n * r3_n = r0->ptr0004;
	word32 r2_n = r0->dw0000;
	r1->ptr0008 = r3_n->ptr0008;
	struct Eq_n * r4_n = r3_n->ptr0008;
	r1->ptr0004 = r3_n;
	r4_n->ptr0004 = r1;
	r3_n->ptr0008 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r2_n + 0x01;
}

// 0000830C: FlagGroup Eq_n vListInsert(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
Eq_n vListInsert(Eq_n * r0, Eq_n * r1)
{
	struct Eq_n * r2_n;
	struct Eq_n * r3_n;
	up32 r5_n = r1->dw0000;
	if (!Z)
	{
		r2_n = (struct Eq_n *) (&r0->dw0000 + 0x02);
		while (true)
		{
			r3_n = r2_n->ptr0004;
			if (r5_n < r3_n->dw0000)
				break;
			r2_n = r3_n;
		}
	}
	else
	{
		r2_n = r0->ptr0010;
		r3_n = r2_n->ptr0004;
	}
	word32 r4_n = r0->dw0000;
	r1->ptr0004 = r3_n;
	r3_n->ptr0008 = r1;
	r1->ptr0008 = r2_n;
	r2_n->ptr0004 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r4_n + 0x01;
	return cond(r4_n + 0x01);
}

// 00008340: Register (ptr32 Eq_n) uxListRemove(Register (ptr32 Eq_n) r0)
Eq_n * uxListRemove(Eq_n * r0)
{
	struct Eq_n * r2_n = r0->ptr0010;
	struct Eq_n * r3_n = r0->ptr0004;
	r3_n->ptr0008 = r0->ptr0008;
	struct Eq_n * r4_n = r2_n->ptr0004;
	struct Eq_n * r1_n = r0->ptr0008;
	r1_n->ptr0004 = r3_n;
	if (r0 == r4_n)
		r2_n->ptr0004 = r1_n;
	word32 r3_n = r2_n->dw0000;
	r0->ptr0010 = null;
	r2_n->dw0000 = r3_n - 0x01;
	return r3_n - 0x01;
}

// 00008364: FlagGroup Eq_n xQueueCRSend(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register word32 cpsr, Register out ptr32 r0Out)
Eq_n xQueueCRSend(Eq_n * r0, Eq_n * r1, Eq_n * r2, word32 cpsr, ptr32 & r0Out)
{
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	if (r0->dw0038 == r0->dw003C)
	{
		Eq_n Z_n = vPortExitCritical(cpsr);
		if (r2 != null)
		{
			Eq_n Z_n = vCoRoutineAddToDelayedList(r2, &r0->dw0010);
			__msr(cpsr, null);
			word32 r0_n;
			*r0Out = ~0x03;
			return Z_n;
		}
		else
		{
			__msr(cpsr, r2);
			word32 r0_n;
			*r0Out = r2;
			return Z_n;
		}
	}
	vPortExitCritical(cpsr);
	__msr(cpsr, null);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	up32 r2_n = r0->dw0038;
	up32 r3_n = r0->dw003C;
	word32 r0_n;
	*r0Out = 0x00;
	Eq_n Z_n = cond(r2_n - r3_n);
	if (r2_n < r3_n)
	{
		word32 r0_n;
		Z_n = prvCopyDataToQueue(r0, r1, 0x00, out r0_n);
		if (r0->dw0024 != 0x00)
		{
			xCoRoutineRemoveFromEventList(&r0->dw0024);
			Z_n = cond(0x01);
			if (0x01 != 0x00)
			{
				word32 r0_n;
				*r0Out = ~0x04;
				goto l000083AA;
			}
		}
		__msr(cpsr, null);
		word32 r0_n;
		*r0Out = 0x01;
		return Z_n;
	}
	else
	{
l000083AA:
		__msr(cpsr, null);
		return Z_n;
	}
}

// 00008400: FlagGroup Eq_n xQueueCRReceive(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2, Register word32 cpsr, Register out ptr32 r0Out)
Eq_n xQueueCRReceive(Eq_n * r0, Eq_n * r1, Eq_n * r2, word32 cpsr, ptr32 & r0Out)
{
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	struct Eq_n * r5_n = r0->ptr0038;
	if (r5_n == null)
	{
		Eq_n NZCV_n = cond(r2);
		if (r2 != null)
		{
			Eq_n Z_n = vCoRoutineAddToDelayedList(r2, &r0->dw0010 + 0x05);
			__msr(cpsr, r5_n);
			word32 r0_n;
			*r0Out = ~0x03;
			return Z_n;
		}
		else
		{
			__msr(cpsr, r2);
			word32 r0_n;
			*r0Out = r2;
			return NZCV_n;
		}
	}
	__msr(cpsr, null);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	struct Eq_n * r2_n = r0->ptr0038;
	if (r2_n != null)
	{
		struct Eq_n * r1_n;
		struct Eq_n * r2_n = r0->ptr0040;
		struct Eq_n * r3_n = r0->ptr0004;
		word32 r1_n = Mem0[r0 + 0x0C:word32] + r2_n;
		struct Eq_n * r3_n = r0->ptr0038;
		r0->ptr000C = r1_n;
		r1_n = r1_n;
		if (r1_n >= r3_n)
			r1_n = r0->ptr0000;
		r0->ptr0038 = (struct Eq_n *) ((char *) &r3_n->dwFFFFFFFC + 0x03);
		if (r1_n >= r3_n)
			r0->ptr000C = r1_n;
		Z = memcpy(r1, r1_n, r2_n);
		if (r0->dw0010 != 0x00)
		{
			xCoRoutineRemoveFromEventList(&r0->dw0010);
			Z = cond(0x01);
			if (0x01 != 0x00)
			{
				word32 r0_n;
				*r0Out = ~0x04;
l00008440:
				__msr(cpsr, null);
				return Z;
			}
		}
		__msr(cpsr, null);
		word32 r0_n;
		*r0Out = 0x01;
		return Z;
	}
	else
	{
		word32 r0_n;
		*r0Out = r2_n;
		goto l00008440;
	}
}

// 000084A0: void xQueueCRSendFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register word32 r2)
void xQueueCRSendFromISR(Eq_n * r0, Eq_n * r1, word32 r2)
{
	if (r0->dw0038 < r0->dw003C)
	{
		word32 r0_n;
		prvCopyDataToQueue(r0, r1, 0x00, out r0_n);
		if (r2 == 0x00 && r0->dw0024 != 0x00)
			xCoRoutineRemoveFromEventList(&r0->dw0024);
	}
}

// 000084D4: void xQueueCRReceiveFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 word32) r2)
void xQueueCRReceiveFromISR(Eq_n * r0, Eq_n * r1, word32 * r2)
{
	if (r0->dw0038 == 0x00)
		return;
	struct Eq_n * r3_n;
	struct Eq_n * lr_n = r0->ptr0040;
	struct Eq_n * r4_n = r0->ptr0004;
	word32 r3_n = Mem0[r0 + 0x0C:word32] + lr_n;
	word32 r7_n = r0->dw0038;
	r0->ptr000C = r3_n;
	r3_n = r3_n;
	if (r3_n >= r4_n)
		r3_n = r0->ptr0000;
	if (r3_n >= r4_n)
		r0->ptr000C = r3_n;
	r0->dw0038 = r7_n + ~0x00;
	memcpy(r1, r3_n, lr_n);
	if (*r2 != 0x00 || r0->dw0010 == 0x00)
		return;
	xCoRoutineRemoveFromEventList(&r0->dw0010);
	if (0x01 == 0x00)
		return;
	*r2 = 0x01;
}

// 0000852C: void prvIdleTask(Register word32 cpsr)
void prvIdleTask(word32 cpsr)
{
	while (true)
		vApplicationIdleHook(cpsr);
}

// 00008534: void xTaskNotifyStateClear(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void xTaskNotifyStateClear(Eq_n * r0, word32 cpsr)
{
	struct Eq_n * r4_n;
	if (r0 != null)
		r4_n = r0;
	else
		r4_n = globals->ptr8560->ptr0004;
	word32 r0_n;
	vPortEnterCritical(cpsr, out r0_n);
	word32 r3_n = (word32) r4_n->b0064;
	if (r3_n == 0x02)
		r3_n = 0x00;
	r4_n->b0064 = (byte) r3_n;
	vPortExitCritical(cpsr);
}

// 00008564: Register word32 xPortRaisePrivilege(Register word32 cpsr)
word32 xPortRaisePrivilege(word32 cpsr)
{
	(__mrs(cpsr) & 0x01) == 0x00;
	__syscall(0x02);
	return 0x01;
}

// 00008578: FlagGroup bool vPortEnterCritical(Register word32 cpsr, Register out ptr32 r0Out)
bool vPortEnterCritical(word32 cpsr, ptr32 & r0Out)
{
	word32 r0_n;
	*r0Out = xPortRaisePrivilege(cpsr);
	__msr(cpsr, &globals->t00BF);
	__isb_sy();
	__dsb_sy();
	word32 * r2_n = globals->ptr85AC;
	++*r2_n;
	bool C_n = (bool) cond(0x00);
	if (0x00 != 0x00)
	{
		struct Eq_n * r0_n = __mrs(cpsr);
		__msr(cpsr, r0_n | 0x01);
		word32 r0_n;
		*r0Out = r0_n | 0x01;
	}
	return C_n;
}

// 000085B0: FlagGroup byte vPortExitCritical(Register word32 cpsr)
byte vPortExitCritical(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	word32 * r2_n = globals->ptr85D8;
	word32 r3_n = *r2_n;
	*r2_n = r3_n - 0x01;
	if (r3_n == 0x01)
		__msr(cpsr, r3_n - 0x01);
	byte NZCV_n = cond(0x00);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return NZCV_n;
}

// 000085DC: void vParTestInitialise()
void vParTestInitialise()
{
	PDCInit();
	ui32 r1_n = (word32) *globals->ptr85F0;
	PDCWrite(0x05, r1_n);
}

// 000085F4: void vParTestSetLED(Register up32 r0, Register word32 r1, Register word32 cpsr)
void vParTestSetLED(up32 r0, word32 r1, word32 cpsr)
{
	MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_n = globals->ptr862C;
		uint32 r0_n = (uint32) (byte) (0x01 << r0);
		ui32 r2_n = (word32) *r3_n;
		if (r1 != 0x00)
			*r3_n = (byte) (r0_n | r2_n);
		else
			*r3_n = (byte) (r2_n & ~(r0_n << 0x00));
		PDCWrite(0x05, (word32) *r3_n);
	}
	MPU_xTaskResumeAll(cpsr);
}

// 00008630: void vParTestToggleLED(Register up32 r0, Register word32 cpsr)
void vParTestToggleLED(up32 r0, word32 cpsr)
{
	MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_n = globals->ptr866C;
		ui32 r0_n = 0x01 << r0;
		uint32 r2_n = (uint32) (byte) r0_n + (word32) (*r3_n) + (r0 < 0x07);
		if (r2_n == 0x00)
			*r3_n = (byte) (r2_n | (word32) (*r3_n));
		else
			*r3_n = (byte) ((word32) *r3_n & ~(r0_n << 0x00));
		PDCWrite(0x05, (word32) *r3_n);
	}
	MPU_xTaskResumeAll(cpsr);
}

// 00008670: void prvFlashCoRoutine(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void prvFlashCoRoutine(Eq_n * r0, word32 cpsr)
{
	struct Eq_n ** r5_n;
	word32 r0_n;
	word32 r3_n = (word32) r0->w0034;
	if (r3_n != 0x01C2)
	{
		if (r3_n == 0x01C3)
		{
			r5_n = globals->ptr86E0;
			goto l00008690;
		}
		if (r3_n != 0x00)
			return;
		r5_n = globals->ptr86E0;
l00008696:
		Eq_n Z_n = xQueueCRReceive(*r5_n, fp - 0x0014, (struct Eq_n *) ~0x00, cpsr, out r0_n);
		if (Z_n)
		{
			r0->w0034 = 0x01C2;
			return;
		}
		if (!Z_n)
		{
l000086AA:
			if (r0_n != 0x01)
			{
				*globals->ptr86E4 = 0x00;
				goto l00008696;
			}
l00008690:
			vParTestToggleLED(dwLoc14, cpsr);
			goto l00008696;
		}
	}
	else
	{
		r5_n = globals->ptr86E0;
		if (xQueueCRReceive(*r5_n, fp - 0x0014, null, cpsr, out r0_n))
			goto l000086AA;
	}
	r0->w0034 = 0x01C3;
}

// 000086E8: void prvFixedDelayCoRoutine(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
void prvFixedDelayCoRoutine(Eq_n * r0, ui32 r1, word32 cpsr)
{
	Eq_n Z_n;
	word32 r0_n;
	struct Eq_n * r0_n;
	up32 r3_n = (word32) r0->w0034;
	if (r3_n != 0x0182)
	{
		if (r3_n > 0x0182)
		{
			if (r3_n == 0x0183)
				goto l00008702;
			if (r3_n != 0x0196)
				return;
		}
		else if (r3_n != 0x00)
			return;
		Z_n = xQueueCRSend(*globals->ptr877C, fp - 0x0C, null, cpsr, out r0_n);
		if (Z_n)
		{
			r0->w0034 = 0x0182;
			return;
		}
	}
	else
		Z_n = xQueueCRSend(*globals->ptr877C, fp - 0x0C, null, cpsr, out r0_n);
	if (Z_n)
	{
		r0->w0034 = 0x0183;
		return;
	}
	if (r0_n != 0x01)
	{
		*globals->ptr8780 = 0x00;
		r0_n = (&globals->ptr8778[r1].dwFFFFFFFC)[0x01];
		if (r0_n == null)
		{
l0000870C:
			r0->w0034 = 0x0196;
			return;
		}
l0000875E:
		vCoRoutineAddToDelayedList(r0_n, null);
		goto l0000870C;
	}
l00008702:
	r0_n = (&globals->ptr8778[r1].dwFFFFFFFC)[0x01];
	if (r0_n == null)
		goto l0000870C;
	goto l0000875E;
}

// 00008784: void vStartFlashCoRoutines(Register up32 r0, Register word32 cpsr)
void vStartFlashCoRoutines(up32 r0, word32 cpsr)
{
	MPU_xQueueGenericCreate(&globals->t0001, 0x04, cpsr);
	*globals->ptr87C4 = 0x01;
	if (0x01 == 0x00)
		return;
	if (0x08 != 0x00)
	{
		struct Eq_n * r4_n = null;
		struct Eq_n * r6_n = globals->ptr87C8;
		do
		{
			xCoRoutineCreate(r6_n, 0x00, r4_n, cpsr);
			r4_n = (struct Eq_n *) ((char *) &r4_n->ptr0000 + 0x01);
		} while (r4_n != &globals->t0008);
	}
	struct Eq_n * r0_n = globals->ptr87CC;
	xCoRoutineCreate(r0_n, 0x01, null, cpsr);
}

// 000087D0: void xAreFlashCoRoutinesStillRunning()
void xAreFlashCoRoutinesStillRunning()
{
}

// 000087DC: void MPU_xTaskCreateRestricted(Register (ptr32 Eq_n) r0, Register (ptr32 (ptr32 Eq_n)) r1, Register word32 cpsr)
void MPU_xTaskCreateRestricted(Eq_n * r0, Eq_n * * r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskCreateRestricted(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008808: void MPU_xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register word32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_n)) dwArg04)
void MPU_xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, word32 cpsr, int32 dwArg00, Eq_n * * dwArg04)
{
	xPortRaisePrivilege(cpsr);
	xTaskCreate(r0, r1, r2, r3, cpsr, dwArg00, dwArg04);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000884C: void MPU_vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_n) r1, Register word32 cpsr)
void MPU_vTaskAllocateMPURegions(word32 r0, Eq_n * r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vTaskAllocateMPURegions(r0, r1);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008874: void MPU_vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register word32 cpsr)
void MPU_vTaskDelayUntil(up32 * r0, word32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vTaskDelayUntil(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000889C: void MPU_vTaskDelay(Register up32 r0, Register word32 cpsr)
void MPU_vTaskDelay(up32 r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vTaskDelay(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000088C0: void MPU_vTaskSuspendAll(Register word32 cpsr)
void MPU_vTaskSuspendAll(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vTaskSuspendAll();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000088E0: void MPU_xTaskResumeAll(Register word32 cpsr)
void MPU_xTaskResumeAll(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskResumeAll(cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008904: void MPU_xTaskGetTickCount(Register word32 cpsr)
void MPU_xTaskGetTickCount(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskGetTickCount();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008928: void MPU_uxTaskGetNumberOfTasks(Register word32 cpsr)
void MPU_uxTaskGetNumberOfTasks(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	uxTaskGetNumberOfTasks();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000894C: void MPU_pcTaskGetName(Register word32 r0, Register word32 cpsr)
void MPU_pcTaskGetName(word32 r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	pcTaskGetName(r0);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008974: void MPU_vTaskSetTimeOutState(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void MPU_vTaskSetTimeOutState(Eq_n * r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vTaskSetTimeOutState(r0);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008998: void MPU_xTaskCheckForTimeOut(Register (ptr32 Eq_n) r0, Register (ptr32 up32) r1, Register word32 cpsr)
void MPU_xTaskCheckForTimeOut(Eq_n * r0, up32 * r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskCheckForTimeOut(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089C4: void MPU_xTaskGenericNotify(Register (ptr32 Eq_n) r0, Register word32 r1, Register up32 r2, Register (ptr32 word32) r3, Register word32 cpsr)
void MPU_xTaskGenericNotify(Eq_n * r0, word32 r1, up32 r2, word32 * r3, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskGenericNotify(r0, r1, r2, r3, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089FC: void MPU_xTaskNotifyWait(Register ui32 r0, Register ui32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register word32 cpsr)
void MPU_xTaskNotifyWait(ui32 r0, ui32 r1, ui32 * r2, up32 r3, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskNotifyWait(r0, r1, r2, r3, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A34: void MPU_ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register word32 cpsr)
void MPU_ulTaskNotifyTake(word32 r0, up32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	ulTaskNotifyTake(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A60: void MPU_xTaskNotifyStateClear(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void MPU_xTaskNotifyStateClear(Eq_n * r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xTaskNotifyStateClear(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A88: void MPU_xQueueGenericCreate(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
void MPU_xQueueGenericCreate(Eq_n * r0, ui32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGenericCreate(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AB8: void MPU_xQueueGenericReset(Register (ptr32 Eq_n) r0, Register word32 r1, Register word32 cpsr)
void MPU_xQueueGenericReset(Eq_n * r0, word32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGenericReset(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AE4: void MPU_xQueueGenericSend(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register up32 r2, Register word32 r3, Register word32 cpsr)
void MPU_xQueueGenericSend(Eq_n * r0, Eq_n * r1, up32 r2, word32 r3, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGenericSend(r0, r1, r2, r3, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B1C: void MPU_uxQueueMessagesWaiting(Register word32 r0, Register word32 cpsr)
void MPU_uxQueueMessagesWaiting(word32 r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	uxQueueMessagesWaiting(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B44: void MPU_uxQueueSpacesAvailable(Register word32 r0, Register word32 cpsr)
void MPU_uxQueueSpacesAvailable(word32 r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	uxQueueSpacesAvailable(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B6C: void MPU_xQueueGenericReceive(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register up32 r2, Register word32 r3, Register word32 cpsr)
void MPU_xQueueGenericReceive(Eq_n * r0, Eq_n * r1, up32 r2, word32 r3, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGenericReceive(r0, r1, r2, r3, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BA4: void MPU_xQueuePeekFromISR(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register word32 cpsr)
void MPU_xQueuePeekFromISR(Eq_n * r0, Eq_n * r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueuePeekFromISR(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BD0: void MPU_xQueueGetMutexHolder(Register (ptr32 word32) r0, Register word32 cpsr)
void MPU_xQueueGetMutexHolder(word32 * r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGetMutexHolder(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BF8: void MPU_xQueueCreateMutex(Register word32 cpsr)
void MPU_xQueueCreateMutex(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueCreateMutex(cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C20: void MPU_xQueueTakeMutexRecursive(Register (ptr32 Eq_n) r0, Register up32 r1, Register word32 cpsr)
void MPU_xQueueTakeMutexRecursive(Eq_n * r0, up32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueTakeMutexRecursive(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C4C: void MPU_xQueueGiveMutexRecursive(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void MPU_xQueueGiveMutexRecursive(Eq_n * r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xQueueGiveMutexRecursive(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C74: void MPU_vQueueDelete(Register word32 cpsr)
void MPU_vQueueDelete(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vQueueDelete();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C98: void MPU_pvPortMalloc(Register ui32 r0, Register word32 cpsr)
void MPU_pvPortMalloc(ui32 r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	pvPortMalloc(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CC0: void MPU_vPortFree(Register word32 cpsr)
void MPU_vPortFree(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vPortFree();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CE4: void MPU_vPortInitialiseBlocks(Register word32 cpsr)
void MPU_vPortInitialiseBlocks(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vPortInitialiseBlocks();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D04: void MPU_xPortGetFreeHeapSize(Register word32 cpsr)
void MPU_xPortGetFreeHeapSize(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xPortGetFreeHeapSize();
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D28: void MPU_xEventGroupCreate(Register word32 cpsr)
void MPU_xEventGroupCreate(word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xEventGroupCreate(cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D4C: void MPU_xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register word32 cpsr, Stack up32 dwArg00)
void MPU_xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, word32 cpsr, up32 dwArg00)
{
	xPortRaisePrivilege(cpsr);
	xEventGroupWaitBits(r0, r1, r2, r3, cpsr, dwArg00);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D8C: void MPU_xEventGroupClearBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 cpsr)
void MPU_xEventGroupClearBits(ui32 * r0, ui32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xEventGroupClearBits(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DB8: void MPU_xEventGroupSetBits(Register (ptr32 Eq_n) r0, Register ui32 r1, Register word32 cpsr)
void MPU_xEventGroupSetBits(Eq_n * r0, ui32 r1, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xEventGroupSetBits(r0, r1, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DE4: void MPU_xEventGroupSync(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register word32 cpsr)
void MPU_xEventGroupSync(Eq_n * r0, ui32 r1, ui32 r2, up32 r3, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	xEventGroupSync(r0, r1, r2, r3, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E1C: void MPU_vEventGroupDelete(Register (ptr32 Eq_n) r0, Register word32 cpsr)
void MPU_vEventGroupDelete(Eq_n * r0, word32 cpsr)
{
	xPortRaisePrivilege(cpsr);
	vEventGroupDelete(r0, cpsr);
	if (0x00 != 0x00)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E40: void xCoRoutineCreate(Register (ptr32 Eq_n) r0, Register uint32 r1, Register (ptr32 Eq_n) r2, Register word32 cpsr)
void xCoRoutineCreate(Eq_n * r0, uint32 r1, Eq_n * r2, word32 cpsr)
{
	uint32 r5_n = r1;
	struct Eq_n * r0_n = pvPortMalloc(0x38, cpsr);
	if (r0_n == null)
		return;
	struct Eq_n * r7_n = globals->ptr8EEC;
	if (r7_n->ptr0000 == null)
	{
		r7_n->ptr0000 = r0_n;
		vListInitialise((char *) &r7_n->ptr0000 + 0x04);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0018);
		vListInitialise((char *) &r7_n->ptr0000 + 44);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0040);
		vListInitialise((char *) &r7_n->ptr0000 + 0x0054);
		r7_n->ptr0068 = (char *) &r7_n->ptr0000 + 44;
		r7_n->ptr006C = (char *) &r7_n->ptr0000 + 0x0040;
	}
	if (r1 >= 0x01)
		r5_n = 0x01;
	r0_n->w0034 = 0x00;
	r0_n->dw002C = r5_n;
	r0_n->ptr0030 = r2;
	r0_n->ptr0000 = r0;
	vListInitialiseItem(&r0_n->dw0004);
	vListInitialiseItem(&r0_n->dw0018);
	uint32 r0_n = r0_n->dw002C;
	word32 r5_n = 0x02 - r5_n;
	if (r0_n > r7_n->dw0070)
		r7_n->dw0070 = r0_n;
	r0_n->dw0018 = r5_n;
	r0_n->ptr0010 = r0_n;
	r0_n->ptr0024 = r0_n;
	vListInsertEnd((char *) &r7_n->ptr0000 + 0x04 + r0_n * 0x14, &r0_n->dw0004);
}

// 00008EF0: FlagGroup Eq_n vCoRoutineAddToDelayedList(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
Eq_n vCoRoutineAddToDelayedList(Eq_n * r0, Eq_n * r1)
{
	struct Eq_n * r4_n = globals->ptr8F28;
	up32 r5_n = r0 + r4_n->dw0074 / 0x001C;
	uxListRemove(&r4_n->ptr0000->dw0004);
	up32 r3_n = r4_n->dw0074;
	struct Eq_n * r1_n = r4_n->ptr0000;
	r1_n->dw0004 = r5_n;
	Eq_n Z_n = vListInsert(r4_n->ptr0068, &r1_n->dw0004);
	if (r1 == null)
		return Z_n;
	struct Eq_n * r1_n = r4_n->ptr0000;
	return vListInsert(r1, &r1_n->dw0004 + 0x05);
}

// 00008F2C: void vCoRoutineSchedule(Register word32 cpsr)
void vCoRoutineSchedule(word32 cpsr)
{
	struct Eq_n * r5_n = globals->ptr9088;
	while (r5_n->dw0054 != 0x00)
	{
		__msr(cpsr, &globals->t00BF);
		__isb_sy();
		__dsb_sy();
		struct Eq_n * r4_n = r5_n->ptr0060->ptr000C;
		uxListRemove((char *) r4_n + 0x0018);
		__msr(cpsr, null);
		uxListRemove((char *) r4_n + 0x04);
		uint32 r3_n = r4_n->dw002C;
		r0 = (struct Eq_n *) ((char *) &r5_n->ptr0000 + 0x04 + r3_n * 0x14);
		if (r3_n > r5_n->dw0070)
			r5_n->dw0070 = r3_n;
		vListInsertEnd(r0, (char *) r4_n + 0x04);
	}
	MPU_xTaskGetTickCount(cpsr);
	up32 r3_n = r5_n->dw0074;
	word32 r0_n = r0 - r5_n->dw0078;
	word32 r8_n = globals->dw9090;
	r5_n->dw007C = r0_n;
l00008F94:
	while (r0_n != 0x00)
	{
		struct Eq_n * r2_n;
		++r3_n;
		r5_n->dw0074 = r3_n;
		--r0_n;
		r5_n->dw007C = r0_n;
		if (r3_n != 0x00)
			r2_n = r5_n->ptr0068;
		else
		{
			r2_n = r5_n->ptr006C;
			r5_n->ptr006C = r5_n->ptr0068;
			r5_n->ptr0068 = r2_n;
		}
		if (r2_n->dw0000 == 0x00)
			goto l00008F94;
		struct Eq_n * r4_n = r2_n->ptr000C->ptr000C;
		if (r3_n < r4_n->dw0004)
			goto l00008F94;
		do
		{
			__msr(cpsr, &globals->t00BF);
			__isb_sy();
			__dsb_sy();
			struct Eq_n * r6_n = &r4_n->dw0004;
			uxListRemove(r6_n);
			struct Eq_n * r0_n = &r4_n->dw0004 + 0x05;
			if (r4_n->dw0028 != 0x00)
				uxListRemove(r0_n);
			__msr(cpsr, null);
			uint32 r3_n = r4_n->dw002C;
			struct Eq_n * r0_n = r8_n + r3_n * 0x14;
			if (r3_n > r5_n->dw0070)
				r5_n->dw0070 = r3_n;
			vListInsertEnd(r0_n, r6_n);
			struct Eq_n * r3_n = r5_n->ptr0068;
			if (r3_n->dw0000 == 0x00)
			{
				r3_n = r5_n->dw0074;
				break;
			}
			r4_n = r3_n->ptr000C->ptr000C;
			r3_n = r5_n->dw0074;
		} while (r4_n->dw0004 <= r3_n);
		r0_n = r5_n->dw007C;
	}
	uint32 r2_n;
	uint32 r1_n = r5_n->dw0070;
	r5_n->dw0078 = r3_n;
	ui32 r3_n = r1_n << 0x02;
	if (*((char *) &(r5_n + (r1_n * 0x14) / 0x0080)->ptr0000 + 0x04) == 0x00)
	{
		if (r1_n == 0x00)
			return;
		r3_n = r1_n - 0x01 << 0x02;
		r2_n = r1_n - 0x01;
		if (*((char *) &(r5_n + (r3_n + (r1_n - 0x01) << 0x02) / 0x0080)->ptr0000 + 0x04) == 0x00)
		{
			if (r1_n == 0x01)
			{
l00009046:
				r5_n->dw0070 = r2_n;
				return;
			}
			r3_n = r1_n - 0x02 << 0x02;
			r2_n = r1_n - 0x02;
			if (*((char *) &(r5_n + (r3_n + (r1_n - 0x02) << 0x02) / 0x0080)->ptr0000 + 0x04) == 0x00)
				goto l00009046;
		}
		r5_n->dw0070 = r2_n;
	}
	else
		r2_n = r1_n;
	struct Eq_n * r2_n;
	ui32 r3_n = r3_n + r2_n;
	struct Eq_n * r1_n = r5_n + (r3_n << 0x02) / 0x0080;
	struct Eq_n * r2_n = r1_n->ptr0008->ptr0004;
	struct Eq_n * r3_n = (r3_n << 0x02) + globals->dw908C;
	r1_n->ptr0008 = r2_n;
	r2_n = r2_n;
	if (r2_n == r3_n)
		r2_n = r2_n->ptr0004;
	<anonymous> ** r0_n = r2_n->ptr000C;
	if (r2_n == r3_n)
		r1_n->ptr0008 = r2_n;
	r5_n->ptr0000 = r0_n;
	<anonymous> * r3_n = *r0_n;
	word32 sp_n;
	word32 r4_n;
	word32 r5_n;
	word32 r6_n;
	word32 r7_n;
	word32 r8_n;
	word32 lr_n;
	word32 pc_n;
	word32 r3_n;
	word32 cpsr_n;
	word32 r0_n;
	word32 r2_n;
	byte NZCV_n;
	word32 r1_n;
	byte ZC_n;
	byte Z_n;
	byte C_n;
	byte NZC_n;
	r3_n();
}

// 00009094: FlagGroup bool xCoRoutineRemoveFromEventList(Register (ptr32 Eq_n) r0)
bool xCoRoutineRemoveFromEventList(Eq_n * r0)
{
	struct Eq_n * r4_n = r0->ptr000C->ptr000C;
	struct Eq_n ** r5_n = globals->ptr90C0;
	uxListRemove((char *) r4_n + 0x0018);
	vListInsertEnd((char *) r5_n + 0x0054, (char *) r4_n + 0x0018);
	up32 r0_n = r4_n->dw002C;
	up32 r3_n = *((char *) *r5_n + 44);
	bool Z_n = (bool) cond(r0_n - r3_n);
	return Z_n;
}

// 000090C4: void GPIOGetIntNumber(Register up32 r0)
void GPIOGetIntNumber(up32 r0)
{
	up32 r3_n = globals->dw9104;
	if (r0 == r3_n)
		return;
	if (r0 > r3_n)
	{
		up32 r3_n = globals->dw9108;
		if (r0 == r3_n)
			return;
		if (r0 != r3_n + 0x0001D000)
			;
	}
	else
	{
		if (r0 == 0x40004000)
			return;
		if (r0 != r3_n - 0x1000)
			;
	}
}

// 0000910C: void GPIODirModeSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void GPIODirModeSet(Eq_n * r0, ui32 r1, ui32 r2)
{
	ui32 r3_n = r0->dw0400;
	if ((r2 & 0x01) != 0x00)
		r3_n |= r1;
	r0->dw0400 = r3_n & ~r1;
	ui32 r3_n = r0->dw0420;
	if (r2 << 0x001E < 0x00)
		r1 |= r3_n;
	r0->dw0420 = r3_n & ~(r1 << 0x00);
}

// 00009134: void GPIODirModeGet(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIODirModeGet(Eq_n * r0, word32 r1)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r2_n = r0->dw0420;
	up32 r4_n = (bool) C + (r0->dw0400 + r1_n);
}

// 0000915C: void GPIOIntTypeSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void GPIOIntTypeSet(Eq_n * r0, ui32 r1, ui32 r2)
{
	ui32 r3_n = r0->dw0408;
	if ((r2 & 0x01) != 0x00)
		r3_n |= r1;
	r0->dw0408 = r3_n & ~r1;
	ui32 r3_n = r0->dw0404;
	if ((r2 & 0x02) != 0x00)
		r3_n |= r1;
	r0->dw0404 = r3_n & ~r1;
	ui32 r3_n = r0->dw040C;
	if (r2 << 0x001D < 0x00)
		r1 |= r3_n;
	r0->dw040C = r3_n & ~(r1 << 0x00);
}

// 00009194: void GPIOIntTypeGet(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIOIntTypeGet(Eq_n * r0, word32 r1)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r3_n = r0->dw0404;
	up32 r2_n = (bool) C + (r0->dw0408 + r1_n);
	word32 r0_n = r0->dw040C;
	up32 r3_n = (bool) (r2_n < 0x00) + (r3_n + r1_n);
}

// 000091C8: void GPIOPadConfigSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register ui32 r3)
void GPIOPadConfigSet(Eq_n * r0, ui32 r1, ui32 r2, ui32 r3)
{
	ui32 r4_n = r0->dw0500;
	if ((r2 & 0x01) != 0x00)
		r4_n |= r1;
	r0->dw0500 = r4_n & ~r1;
	ui32 r4_n = r0->dw0504;
	if ((r2 & 0x02) != 0x00)
		r4_n |= r1;
	r0->dw0504 = r4_n & ~r1;
	ui32 r4_n = r0->dw0508;
	if ((r2 & 0x04) != 0x00)
		r4_n |= r1;
	r0->dw0508 = r4_n & ~r1;
	ui32 r2_n = r0->dw0518;
	if ((r2 & 0x08) != 0x00)
		r2_n |= r1;
	r0->dw0518 = r2_n & ~r1;
	ui32 r2_n = r0->dw050C;
	if (r3 << 0x001F < 0x00)
		r2_n |= r1;
	r0->dw050C = r2_n & ~r1;
	ui32 r2_n = r0->dw0510;
	if (r3 << 0x001E < 0x00)
		r2_n |= r1;
	r0->dw0510 = r2_n & ~r1;
	ui32 r2_n = r0->dw0514;
	if (r3 << 0x001D < 0x00)
		r2_n |= r1;
	r0->dw0514 = r2_n & ~r1;
	ui32 r3_n = r0->dw051C;
	if ((r3 & 0x08) != 0x00)
		r1 |= r3_n;
	r0->dw051C = r3_n & ~(r1 << 0x00);
}

// 0000925C: void GPIOPadConfigGet(Register (ptr32 Eq_n) r0, Register word32 r1, Register (ptr32 word32) r2, Register (ptr32 ui32) r3)
void GPIOPadConfigGet(Eq_n * r0, word32 r1, word32 * r2, ui32 * r3)
{
	uint32 r1_n = (uint32) (byte) (0x01 << r1);
	word32 r4_n = r0->dw0504;
	up32 r5_n = (bool) C + (r0->dw0500 + r1_n);
	word32 r5_n = r0->dw0508;
	up32 r4_n = (bool) (r5_n < 0x00) + (r4_n + r1_n);
	word32 r4_n = r0->dw0518;
	up32 r5_n = (bool) (r4_n < 0x00) + (r5_n + r1_n);
	*r2 = 0x00;
	ui32 r5_n = 0x00;
	word32 r4_n = r0->dw0510;
	uint32 r1_n = r1_n + r0->dw050C;
	word32 r6_n = r0->dw0514;
	if (r1_n != 0x00)
		r5_n = 0x01;
	word32 r2_n = r0->dw051C;
	if (r1_n == 0x00)
		r5_n = 0x00;
	uint32 r1_n = r1_n + r4_n + (r1_n < 0x00);
	uint32 r1_n = r1_n + r6_n + (r1_n < 0x00);
	*r3 = r5_n << 0x00;
}

// 000092E0: void GPIOPinIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinIntEnable(Eq_n * r0, ui32 r1)
{
	r0->dw0410 = r1 | r0->dw0410;
}

// 000092EC: void GPIOPinIntDisable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinIntDisable(Eq_n * r0, ui32 r1)
{
	r0->dw0410 &= ~(r1 << 0x00);
}

// 000092FC: void GPIOPinIntStatus(Register word32 r0, Register word32 r1)
void GPIOPinIntStatus(word32 r0, word32 r1)
{
	if (r1 != 0x00)
		;
}

// 0000930C: void GPIOPinIntClear(Register (ptr32 Eq_n) r0, Register word32 r1)
void GPIOPinIntClear(Eq_n * r0, word32 r1)
{
	r0->dw041C = r1;
}

// 00009314: void GPIOPortIntRegister(Register up32 r0, Register word32 r1)
void GPIOPortIntRegister(up32 r0, word32 r1)
{
	up32 r3_n = globals->dw93A8;
	if (r0 == r3_n)
	{
		IntRegister(0x12, r1);
		IntEnable(0x12);
	}
	else
	{
		if (r0 <= r3_n)
		{
			if (r0 == 0x40004000)
			{
				IntRegister(0x10, r1);
				IntEnable(0x10);
				return;
			}
			if (r0 == r3_n - 0x1000)
			{
				IntRegister(0x11, r1);
				IntEnable(0x11);
				return;
			}
		}
		else
		{
			up32 r3_n = globals->dw93AC;
			if (r0 == r3_n)
			{
				IntRegister(0x13, r1);
				IntEnable(0x13);
				return;
			}
			if (r0 == r3_n + 0x0001D000)
			{
				IntRegister(0x14, r1);
				IntEnable(0x14);
				return;
			}
		}
		IntRegister(~0x00, r1);
		IntEnable(~0x00);
	}
}

// 000093B0: void GPIOPortIntUnregister(Register up32 r0)
void GPIOPortIntUnregister(up32 r0)
{
	up32 r3_n = globals->dw9444;
	if (r0 == r3_n)
	{
		IntDisable(0x12);
		IntUnregister(0x12);
	}
	else
	{
		if (r0 <= r3_n)
		{
			if (r0 == 0x40004000)
			{
				IntDisable(0x10);
				IntUnregister(0x10);
				return;
			}
			if (r0 == r3_n - 0x1000)
			{
				IntDisable(0x11);
				IntUnregister(0x11);
				return;
			}
		}
		else
		{
			up32 r3_n = globals->dw9448;
			if (r0 == r3_n)
			{
				IntDisable(0x13);
				IntUnregister(0x13);
				return;
			}
			if (r0 == r3_n + 0x0001D000)
			{
				IntDisable(0x14);
				IntUnregister(0x14);
				return;
			}
		}
		IntDisable(~0x00);
		IntUnregister(~0x00);
	}
}

// 0000944C: void GPIOPinRead(Register word32 r0, Register word32 r1)
void GPIOPinRead(word32 r0, word32 r1)
{
}

// 00009454: void GPIOPinWrite(Register (arr word32) r0, Register ui32 r1, Register word32 r2)
void GPIOPinWrite(word32 r0[], ui32 r1, word32 r2)
{
	r0[r1] = r2;
}

// 0000945C: void GPIOPinTypeComparator(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeComparator(Eq_n * r0, ui32 r1)
{
	ui32 r5_n = ~r1;
	r0->dw0400 &= r5_n;
	r0->dw0420 = r5_n & r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x00);
}

// 00009480: void GPIOPinTypeI2C(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeI2C(Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~(r1 << 0x00);
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 11);
}

// 000094A4: void GPIOPinTypeQEI(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeQEI(Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~(r1 << 0x00);
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x0A);
}

// 000094C8: void GPIOPinTypeUART(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeUART(Eq_n * r0, ui32 r1)
{
	r0->dw0400 &= ~(r1 << 0x00);
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x08);
}

// 000094EC: void GPIOPinTypeTimer(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeTimer(Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F0: void GPIOPinTypeSSI(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypeSSI(Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F4: void GPIOPinTypePWM(Register (ptr32 Eq_n) r0, Register ui32 r1)
void GPIOPinTypePWM(Eq_n * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F8: void IntDefaultHandler()
void IntDefaultHandler()
{
	while (true)
		;
}

// 000094FC: void IntMasterEnable()
void IntMasterEnable()
{
	CPUcpsie();
}

// 00009500: void IntMasterDisable()
void IntMasterDisable()
{
	CPUcpsid();
}

// 00009504: void IntRegister(Register ui32 r0, Register word32 r1)
void IntRegister(ui32 r0, word32 r1)
{
	word32 r4_n[] = globals->ptr9534;
	if (*globals->ptr9530 != r4_n)
	{
		word32 r3_n[] = r4_n;
		do
		{
			Mem29[r3_n + 0x00:word32] = Mem0[r3_n - r4_n + 0x00:word32];
			r3_n = (word32 (*)[]) (r3_n + 0x01);
		} while (r3_n != r4_n + 0x002E);
		*globals->ptr9530 = r4_n;
	}
	r4_n[r0] = r1;
}

// 00009538: void IntUnregister(Register ui32 r0)
void IntUnregister(ui32 r0)
{
	globals->ptr9544[r0] = globals->dw9548;
}

// 0000954C: void IntPriorityGroupingSet(Register ui32 r0)
void IntPriorityGroupingSet(ui32 r0)
{
	*globals->ptr9564 = globals->ptr9560[r0] | 0x05F80000 | 0x00020000;
}

// 00009568: void IntPriorityGroupingGet()
void IntPriorityGroupingGet()
{
	ui32 r3_n = 0x0700;
	word32 r0_n = 0x00;
	ui32 r1_n = *globals->ptr9588;
	word32 * r2_n = globals->ptr958C;
	while (r3_n != (r1_n & 0x0700))
	{
		++r0_n;
		if (r0_n == 0x08)
			return;
		++r2_n;
		r3_n = *r2_n;
	}
}

// 00009590: void IntPrioritySet(Register ui32 r0, Register ui32 r1)
void IntPrioritySet(ui32 r0, ui32 r1)
{
	ui32 * r4_n = (globals->ptr95B8 + (r0 & ~0x03))->ptr0020;
	ui32 r0_n = (r0 & 0x03) << 0x03;
	*r4_n = r1 << r0_n | *r4_n & ~((0xFF << r0_n) << 0x00);
}

// 000095BC: void IntPriorityGet(Register word32 r0)
void IntPriorityGet(word32 r0)
{
}

// 000095DC: void IntEnable(Register up32 r0)
void IntEnable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_n = globals->ptr9634;
		*r2_n |= 0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_n = globals->ptr9630;
		*r2_n |= 0x02;
	}
	else if (r0 > 0x0F)
		*globals->ptr962C = 0x01 << r0 - 0x10;
}

// 00009638: void IntDisable(Register up32 r0)
void IntDisable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_n = globals->ptr9690;
		*r2_n &= ~0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_n = globals->ptr968C;
		*r2_n &= ~0x02;
	}
	else if (r0 > 0x0F)
		*globals->ptr9688 = 0x01 << r0 - 0x10;
}

// 00009694: void OSRAMDelay(Register word32 r0)
void OSRAMDelay(word32 r0)
{
	do
		--r0;
	while (r0 != 0x00);
}

// 0000969C: void OSRAMWriteFirst(Register ui32 r0)
void OSRAMWriteFirst(ui32 r0)
{
	struct Eq_n * r4_n = globals->ptr96C0;
	I2CMasterSlaveAddrSet(r4_n, 0x3D, 0x00);
	I2CMasterDataPut(r4_n, r0);
	I2CMasterControl(r4_n, 0x03);
}

// 000096C4: void OSRAMWriteArray(Register (ptr32 byte) r0, Register int32 r1)
void OSRAMWriteArray(byte * r0, int32 r1)
{
	if (r1 == 0x00)
		return;
	byte * r5_n;
	word32 * r7_n = globals->ptr96FC;
	struct Eq_n * r4_n = globals->ptr9700;
	byte * r6_n = r0 + r1;
	do
	{
		do
			;
		while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
		OSRAMDelay(*r7_n);
		I2CMasterDataPut(r4_n, (word32) *r5_n);
		I2CMasterControl(r4_n, 0x01);
		++r5_n;
	} while (r6_n != r5_n);
}

// 00009704: void OSRAMWriteByte(Register ui32 r0)
void OSRAMWriteByte(ui32 r0)
{
	do
		;
	while (I2CMasterIntStatus(globals->ptr9730, 0x00) == 0x00);
	OSRAMDelay(*globals->ptr9734);
	I2CMasterDataPut(globals->ptr9730, r0);
	struct Eq_n * r0_n = globals->ptr9730;
	I2CMasterControl(r0_n, 0x01);
}

// 00009738: void OSRAMWriteFinal(Register ui32 r0)
void OSRAMWriteFinal(ui32 r0)
{
	struct Eq_n * r4_n = globals->ptr9778;
	do
		;
	while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
	word32 * r5_n = globals->ptr977C;
	struct Eq_n * r4_n = globals->ptr9778;
	OSRAMDelay(*r5_n);
	I2CMasterDataPut(r4_n, r0);
	I2CMasterControl(r4_n, 0x05);
	do
		;
	while (I2CMasterIntStatus(r4_n, 0x00) == 0x00);
	word32 r0_n = *r5_n;
	OSRAMDelay(r0_n);
}

// 00009780: void OSRAMClear()
void OSRAMClear()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(globals->ptr97C4, 0x06);
	ui32 r4_n;
	for (r4_n = 0x5F; r4_n != 0x00; --r4_n)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_n);
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(globals->ptr97C8, 0x06);
	ui32 r4_n;
	for (r4_n = 0x5F; r4_n != 0x00; --r4_n)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_n);
}

// 000097CC: void OSRAMStringDraw(Register (ptr32 byte) r0, Register uint32 r1, Register ui32 r2)
void OSRAMStringDraw(byte * r0, uint32 r1, ui32 r2)
{
	OSRAMWriteFirst(0x80);
	uint32 r4_n = r1;
	byte * r5_n = r0;
	OSRAMWriteByte(177);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(r1 + 0x24 & 0x0F);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte((uint32) SLICE(r1 + 0x24, ui4, 4) | 0x10);
	OSRAMWriteByte(0x40);
	ui32 r3_n = (word32) *r0;
	if (r3_n == 0x00)
		return;
	word32 r6_n = globals->dw9878;
	if (r1 <= 0x5A)
	{
		do
		{
			OSRAMWriteArray(r6_n + (r3_n - 0x20) * 0x05, 0x05);
			if (r4_n == 0x5A)
			{
l00009846:
				OSRAMWriteFinal(0x00);
				return;
			}
			++r5_n;
			r4_n += 0x06;
			if ((word32) *r5_n == 0x00)
				goto l00009846;
			OSRAMWriteByte(0x00);
			r3_n = (word32) *r5_n;
			if (r3_n == 0x00)
				return;
		} while (r4_n <= 0x5A);
	}
	int32 r4_n = 0x5F - r4_n;
	OSRAMWriteArray(r6_n + (r3_n - 0x20) * 0x05, r4_n);
	Eq_n r3_n = (word32) *r5_n;
	ui32 r0_n = (word32) (r3_n - 0x20 + (r3_n - 0x20 << 0x02) + globals->dw987C + r4_n)->b0010;
	OSRAMWriteFinal(r0_n);
}

// 00009880: void OSRAMImageDraw(Register (ptr32 byte) r0, Register word32 r1, Register word32 r2, Register word32 r3, Stack word32 dwArg00)
void OSRAMImageDraw(byte * r0, word32 r1, word32 r2, word32 r3, word32 dwArg00)
{
	if (dwArg00 != 0x00)
	{
		byte * r5_n = r0;
		word32 r4_n;
		uint32 r8_n = (uint32) SLICE(r1 + 0x24, ui4, 4);
		word32 r6_n = dwArg00 + r2;
		ui32 r7_n = r1 + 0x24 & 0x0F;
		do
		{
			OSRAMWriteFirst(0x80);
			OSRAMWriteByte(0xB0);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r7_n);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r8_n | 0x10);
			OSRAMWriteByte(0x40);
			OSRAMWriteArray(r5_n, r3 + ~0x00);
			r5_n += r3;
			OSRAMWriteFinal((word32) *(r5_n - 0x01));
			++r4_n;
		} while (r6_n != r4_n);
	}
}

// 000098F0: void OSRAMInit(Register word32 r0)
void OSRAMInit(word32 r0)
{
	SysCtlPeripheralEnable(0x10001000);
	SysCtlPeripheralEnable(globals->dw9960);
	GPIOPinTypeI2C(globals->ptr9964, 0x0C);
	I2CMasterInit(globals->ptr9968, r0);
	word32 r7_n = globals->dw9970;
	*globals->ptr996C = 0x01;
	ui32 r6_n = 227;
	int32 r4_n = 0x04;
	ui32 r0_n = 0x80;
	uint32 r5_n = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_n);
		OSRAMWriteArray(r5_n + 0x02 + (r7_n + 0x01EC), r4_n - 0x02);
		OSRAMWriteFinal(r6_n);
		r5_n += r4_n + 0x01;
		struct Eq_n * r3_n = r7_n + (r5_n << 0x00);
		if (r5_n > 0x70)
			break;
		r4_n = (word32) r3_n->b01EC;
		r0_n = (word32) r3_n->b01ED;
		r6_n = (word32) (r3_n + r4_n / 0x01EE)->b01EC;
	}
	OSRAMClear();
}

// 00009974: void OSRAMDisplayOn()
void OSRAMDisplayOn()
{
	word32 r7_n = globals->dw99BC;
	ui32 r6_n = 227;
	int32 r4_n = 0x04;
	ui32 r0_n = 0x80;
	uint32 r5_n = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_n);
		OSRAMWriteArray(r5_n + 0x02 + (r7_n + 0x01EC), r4_n - 0x02);
		OSRAMWriteFinal(r6_n);
		r5_n += r4_n + 0x01;
		struct Eq_n * r3_n = r7_n + (r5_n << 0x00);
		if (r5_n > 0x70)
			break;
		r4_n = (word32) r3_n->b01EC;
		r0_n = (word32) r3_n->b01ED;
		r6_n = (word32) (r3_n + r4_n / 0x01EE)->b01EC;
	}
}

// 000099C0: void OSRAMDisplayOff()
void OSRAMDisplayOff()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteByte(0xAE);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(0xAD);
	OSRAMWriteByte(0x80);
	OSRAMWriteFinal(0x8A);
}

// 000099E8: void SSIConfig(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2, Register uint32 r3, Stack ui32 dwArg00)
void SSIConfig(Eq_n * r0, ui32 r1, ui32 r2, uint32 r3, ui32 dwArg00)
{
	ui32 r7_n = r2;
	uint32 r0_n = SysCtlClockGet();
	if (r2 != 0x02)
	{
		if (r2 != 0x00)
			r7_n = 0x04;
	}
	else
		r7_n = 0x0C;
	r0->dw0004 = r7_n;
	uint32 r3_n = r0_n /u r3;
	uint32 r4_n = 0x00;
	do
	{
		r4_n += 0x02;
		uint32 r2_n = r3_n /u r4_n;
	} while (r2_n > 0x0100 || r2_n < 0x01);
	r0->dw0010 = r4_n;
	r0->dw0000 = dwArg00 - 0x01 | (r1 & 0x30 | r1 << 0x06) | r2_n - 0x01 << 0x08;
}

// 00009A34: void SSIEnable(Register (ptr32 Eq_n) r0)
void SSIEnable(Eq_n * r0)
{
	r0->dw0004 |= 0x02;
}

// 00009A40: void SSIDisable(Register (ptr32 Eq_n) r0)
void SSIDisable(Eq_n * r0)
{
	r0->dw0004 &= ~0x02;
}

// 00009A4C: void SSIIntRegister(Register word32 r1)
void SSIIntRegister(word32 r1)
{
	IntRegister(0x17, r1);
	IntEnable(0x17);
}

// 00009A60: void SSIIntUnregister()
void SSIIntUnregister()
{
	IntDisable(0x17);
	IntUnregister(0x17);
}

// 00009A74: void SSIIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void SSIIntEnable(Eq_n * r0, ui32 r1)
{
	r0->dw0014 = r1 | r0->dw0014;
}

// 00009A7C: void SSIIntDisable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void SSIIntDisable(Eq_n * r0, ui32 r1)
{
	r0->dw0014 &= ~(r1 << 0x00);
}

// 00009A88: void SSIIntStatus(Register word32 r0, Register word32 r1)
void SSIIntStatus(word32 r0, word32 r1)
{
	if (r1 != 0x00)
		;
}

// 00009A94: void SSIIntClear(Register (ptr32 Eq_n) r0, Register word32 r1)
void SSIIntClear(Eq_n * r0, word32 r1)
{
	r0->dw0020 = r1;
}

// 00009A98: void SSIDataPut(Register (ptr32 Eq_n) r0, Register ui32 r1)
void SSIDataPut(Eq_n * r0, ui32 r1)
{
	do
		;
	while (r0->dw000C << 0x001E >= 0x00);
	r0->dw0008 = r1;
}

// 00009AA8: void SSIDataNonBlockingPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void SSIDataNonBlockingPut(Eq_n * r0, word32 r1)
{
	if ((r0->dw000C & 0x02) != 0x00)
		r0->dw0008 = r1;
}

// 00009AB8: void SSIDataGet(Register (ptr32 Eq_n) r0, Register (ptr32 ui32) r1)
void SSIDataGet(Eq_n * r0, ui32 * r1)
{
	do
		;
	while (r0->dw000C << 0x001D >= 0x00);
	*r1 = r0->dw0008;
}

// 00009AC8: void SSIDataNonBlockingGet(Register (ptr32 Eq_n) r0, Register (ptr32 ui32) r1)
void SSIDataNonBlockingGet(Eq_n * r0, ui32 * r1)
{
	ui32 r3_n = r0->dw000C;
	ui32 r3_n = r3_n & 0x04;
	if ((r3_n & 0x04) != 0x00)
		r3_n = r0->dw0008;
	*r1 = r3_n;
}

// 00009ADC: void SysCtlSRAMSizeGet()
void SysCtlSRAMSizeGet()
{
}

// 00009AF4: void SysCtlFlashSizeGet()
void SysCtlFlashSizeGet()
{
}

// 00009B0C: void SysCtlPinPresent(Register word32 r0)
void SysCtlPinPresent(word32 r0)
{
	(bool) C + (*globals->ptr9B1C + r0) == 0x00;
}

// 00009B20: void SysCtlPeripheralPresent(Register uint32 r0)
void SysCtlPeripheralPresent(uint32 r0)
{
	(r0 & ~0xF0000000) + *(globals->ptr9B38)[r0 >> 0x001C] + (r0 >> 0x001C < 0x00) == 0x00;
}

// 00009B3C: void SysCtlPeripheralReset(Register uint32 r0)
void SysCtlPeripheralReset(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9B78 + ((r0 >> 0x001C) << 0x02))->ptr0010;
	*r2_n = r0 & ~0xF0000000 | *r2_n;
	up32 dwLoc0C_n = 0x00;
	if (true)
	{
		do
		{
			up32 r3_n = dwLoc0C_n + 0x01;
			dwLoc0C_n = r3_n;
		} while (r3_n <= 0x0F);
	}
	*r2_n &= ~(r0 << 0x00);
}

// 00009B7C: void SysCtlPeripheralEnable(Register uint32 r0)
void SysCtlPeripheralEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9B94 + ((r0 >> 0x001C) << 0x02))->ptr001C;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009B98: void SysCtlPeripheralDisable(Register uint32 r0)
void SysCtlPeripheralDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9BB0 + ((r0 >> 0x001C) << 0x02))->ptr001C;
	*r2_n &= ~((r0 & ~0xF0000000) << 0x00);
}

// 00009BB4: void SysCtlPeripheralSleepEnable(Register uint32 r0)
void SysCtlPeripheralSleepEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9BCC + ((r0 >> 0x001C) << 0x02))->ptr0028;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009BD0: void SysCtlPeripheralSleepDisable(Register uint32 r0)
void SysCtlPeripheralSleepDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9BE8 + ((r0 >> 0x001C) << 0x02))->ptr0028;
	*r2_n &= ~((r0 & ~0xF0000000) << 0x00);
}

// 00009BEC: void SysCtlPeripheralDeepSleepEnable(Register uint32 r0)
void SysCtlPeripheralDeepSleepEnable(uint32 r0)
{
	ui32 * r3_n = (globals->ptr9C04 + ((r0 >> 0x001C) << 0x02))->ptr0034;
	*r3_n = r0 & ~0xF0000000 | *r3_n;
}

// 00009C08: void SysCtlPeripheralDeepSleepDisable(Register uint32 r0)
void SysCtlPeripheralDeepSleepDisable(uint32 r0)
{
	ui32 * r2_n = (globals->ptr9C20 + ((r0 >> 0x001C) << 0x02))->ptr0034;
	*r2_n &= ~((r0 & ~0xF0000000) << 0x00);
}

// 00009C24: void SysCtlPeripheralClockGating(Register word32 r0)
void SysCtlPeripheralClockGating(word32 r0)
{
	ui32 * r2_n = globals->ptr9C3C;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x08000000;
	else
		*r2_n = r3_n & ~0x08000000;
}

// 00009C40: void SysCtlIntRegister(Register word32 r0)
void SysCtlIntRegister(word32 r0)
{
	IntRegister(44, r0);
	IntEnable(44);
}

// 00009C54: void SysCtlIntUnregister()
void SysCtlIntUnregister()
{
	IntDisable(44);
	IntUnregister(44);
}

// 00009C68: void SysCtlIntEnable(Register ui32 r0)
void SysCtlIntEnable(ui32 r0)
{
	ui32 * r2_n = globals->ptr9C74;
	*r2_n = r0 | *r2_n;
}

// 00009C78: void SysCtlIntDisable(Register ui32 r0)
void SysCtlIntDisable(ui32 r0)
{
	ui32 * r2_n = globals->ptr9C84;
	*r2_n &= ~(r0 << 0x00);
}

// 00009C88: void SysCtlIntClear(Register word32 r0)
void SysCtlIntClear(word32 r0)
{
	*globals->ptr9C90 = r0;
}

// 00009C94: void SysCtlIntStatus(Register word32 r0)
void SysCtlIntStatus(word32 r0)
{
	if (r0 != 0x00)
		;
}

// 00009CAC: void SysCtlLDOSet(Register word32 r0)
void SysCtlLDOSet(word32 r0)
{
	*globals->ptr9CB4 = r0;
}

// 00009CB8: void SysCtlLDOGet()
void SysCtlLDOGet()
{
}

// 00009CC4: void SysCtlLDOConfigSet(Register word32 r0)
void SysCtlLDOConfigSet(word32 r0)
{
	*globals->ptr9CCC = r0;
}

// 00009CD0: void SysCtlReset()
void SysCtlReset()
{
	*globals->ptr9CD8 = globals->dw9CDC;
	while (true)
		;
}

// 00009CE0: void SysCtlSleep()
void SysCtlSleep()
{
	CPUwfi();
}

// 00009CE4: void SysCtlDeepSleep()
void SysCtlDeepSleep()
{
	ui32 * r4_n = globals->ptr9D00;
	*r4_n |= 0x04;
	CPUwfi();
	*r4_n &= ~0x04;
}

// 00009D04: void SysCtlResetCauseGet()
void SysCtlResetCauseGet()
{
}

// 00009D10: void SysCtlResetCauseClear(Register ui32 r0)
void SysCtlResetCauseClear(ui32 r0)
{
	ui32 * r2_n = globals->ptr9D1C;
	*r2_n &= ~(r0 << 0x00);
}

// 00009D20: void SysCtlBrownOutConfigSet(Register ui32 r0, Register ui32 r1)
void SysCtlBrownOutConfigSet(ui32 r0, ui32 r1)
{
	*globals->ptr9D2C = r0 | r1 << 0x02;
}

// 00009D30: void SysCtlClockSet(Register ui32 r0)
void SysCtlClockSet(ui32 r0)
{
	ui32 * r4_n = globals->ptr9DE0;
	ui32 r3_n = *r4_n;
	word32 * r5_n = globals->ptr9DE8;
	ui32 r2_n = r0 & 0x33F0 | (globals->dw9DE4 & r3_n | 0x0800) & (r0 | ~0x03);
	*r4_n = r3_n & ~0x00400000 | 0x0800;
	*r5_n = 0x40;
	*r4_n = r2_n;
	up32 dwLoc14_n = 0x00;
	if (true)
	{
		do
		{
			up32 r3_n = dwLoc14_n + 0x01;
			dwLoc14_n = r3_n;
		} while (r3_n <= 0x0F);
	}
	ui32 r2_n = r2_n & ~0x03 | r0 & 0x03;
	*globals->ptr9DE0 = r2_n;
	ui32 r1_n = r0 & 0x07C00000 | (r2_n & ~0x07C00000) << 0x00;
	if (r0 << 0x0014 >= 0x00)
	{
		word32 dwLoc14_n = 0x8000;
		if (0x8000 != 0x00)
		{
			ui32 * r2_n = globals->ptr9DEC;
			if (*r2_n << 0x0019 >= 0x00)
			{
				do
				{
					word32 r3_n = dwLoc14_n - 0x01;
					dwLoc14_n = r3_n;
				} while (r3_n != 0x00 && *r2_n << 0x0019 >= 0x00);
			}
		}
		r1_n &= ~0x0800;
	}
	*globals->ptr9DE0 = r1_n;
	up32 dwLoc14_n = 0x00;
	if (true)
	{
		do
		{
			up32 r3_n = dwLoc14_n + 0x01;
			dwLoc14_n = r3_n;
		} while (r3_n <= 0x0F);
	}
}

// 00009DF0: Register uint32 SysCtlClockGet()
uint32 SysCtlClockGet()
{
	uint32 r0_n;
	ui32 r3_n = *globals->ptr9E54;
	if ((r3_n & 0x30) != 0x10)
	{
		if ((r3_n & 0x30) != 0x20)
		{
			if ((r3_n & 0x30) != 0x00)
			{
				r0_n = 0x00;
				return r0_n;
			}
			r0_n = (globals->ptr9E58 + ((uint32) SLICE(r3_n, ui4, 6) << 0x02))->dw0030;
		}
		else
			r0_n = globals->dw9E60;
	}
	else
		r0_n = globals->dw9E64;
	if (r3_n << 0x0014 >= 0x00)
	{
		ui32 r2_n = *globals->ptr9E5C;
		r0_n = r0_n * ((uint32) SLICE(r2_n, ui9, 5) + 0x02) /u ((r2_n & 0x1F) + 0x02);
		if (r2_n << 0x0011 < 0x00)
			r0_n >>= 0x01;
		if (r2_n << 0x0010 < 0x00)
			r0_n >>= 0x02;
	}
	if (r3_n << 0x09 >= 0x00)
		return r0_n;
	return r0_n /u ((uint32) SLICE(r3_n, ui4, 23) + 0x01);
}

// 00009E68: void SysCtlPWMClockSet(Register ui32 r0)
void SysCtlPWMClockSet(ui32 r0)
{
	ui32 * r2_n = globals->ptr9E78;
	*r2_n = r0 | *r2_n & ~0x001E0000;
}

// 00009E7C: void SysCtlPWMClockGet()
void SysCtlPWMClockGet()
{
}

// 00009E8C: void SysCtlADCSpeedSet(Register ui32 r0)
void SysCtlADCSpeedSet(ui32 r0)
{
	ui32 * r4_n = globals->ptr9EB8;
	ui32 * r1_n = globals->ptr9EBC;
	ui32 * r2_n = globals->ptr9EC0;
	*r4_n = *r4_n & ~0x0F00 | r0;
	*r1_n = *r1_n & ~0x0F00 | r0;
	*r2_n = r0 | *r2_n & ~0x0F00;
}

// 00009EC4: void SysCtlADCSpeedGet()
void SysCtlADCSpeedGet()
{
}

// 00009ED4: void SysCtlIOSCVerificationSet(Register word32 r0)
void SysCtlIOSCVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9EEC;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x08;
	else
		*r2_n = r3_n & ~0x08;
}

// 00009EF0: void SysCtlMOSCVerificationSet(Register word32 r0)
void SysCtlMOSCVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9F08;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x04;
	else
		*r2_n = r3_n & ~0x04;
}

// 00009F0C: void SysCtlPLLVerificationSet(Register word32 r0)
void SysCtlPLLVerificationSet(word32 r0)
{
	ui32 * r2_n = globals->ptr9F24;
	ui32 r3_n = *r2_n;
	if (r0 != 0x00)
		*r2_n = r3_n | 0x0400;
	else
		*r2_n = r3_n & ~0x0400;
}

// 00009F28: void SysCtlClkVerificationClear()
void SysCtlClkVerificationClear()
{
	word32 * r3_n = globals->ptr9F34;
	*r3_n = 0x01;
	*r3_n = 0x00;
}

// 00009F38: void UARTParityModeSet(Register (ptr32 Eq_n) r0, Register ui32 r1)
void UARTParityModeSet(Eq_n * r0, ui32 r1)
{
	r0->dw002C = r1 | r0->dw002C & ~0x86;
}

// 00009F44: void UARTParityModeGet(Register word32 r0)
void UARTParityModeGet(word32 r0)
{
}

// 00009F4C: void UARTConfigSet(Register (ptr32 Eq_n) r0, Register uint32 r1, Register ui32 r2)
void UARTConfigSet(Eq_n * r0, uint32 r1, ui32 r2)
{
	do
	{
		ui32 r4_n = r0->dw0018;
	} while ((r4_n & 0x08) != 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
	uint32 r0_n = SysCtlClockGet();
	uint32 r2_n = r0_n /u (r1 << 0x04);
	r0->dw0024 = r2_n;
	r0->dw0028 = (r0_n - (r1 << 0x04) * r2_n << 0x03) /u r1 + 0x01 >> 0x01;
	r0->dw002C = r2;
	r0->dw0018 = r4_n & 0x08;
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FA8: void UARTConfigGet(Register (ptr32 Eq_n) r0, Register (ptr32 uint32) r1, Register (ptr32 ui32) r2)
void UARTConfigGet(Eq_n * r0, uint32 * r1, ui32 * r2)
{
	*r1 = (SysCtlClockGet() << 0x02) /u (r0->dw0028 + (r0->dw0024 << 0x06));
	*r2 = r0->dw002C & 0xEE;
}

// 00009FD4: void UARTEnable(Register (ptr32 Eq_n) r0)
void UARTEnable(Eq_n * r0)
{
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FEC: void UARTDisable(Register (ptr32 Eq_n) r0)
void UARTDisable(Eq_n * r0)
{
	do
		;
	while (r0->dw0018 << 0x001C < 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
}

// 0000A00C: void UARTCharsAvail(Register word32 r0)
void UARTCharsAvail(word32 r0)
{
}

// 0000A018: void UARTSpaceAvail(Register word32 r0)
void UARTSpaceAvail(word32 r0)
{
}

// 0000A024: void UARTCharNonBlockingGet(Register (ptr32 Eq_n) r0)
void UARTCharNonBlockingGet(Eq_n * r0)
{
	r0->dw0018 << 0x001B < 0x00;
}

// 0000A034: void UARTCharGet(Register (ptr32 Eq_n) r0)
void UARTCharGet(Eq_n * r0)
{
	do
		;
	while (r0->dw0018 << 0x001B < 0x00);
}

// 0000A044: void UARTCharNonBlockingPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTCharNonBlockingPut(Eq_n * r0, word32 r1)
{
	if (r0->dw0018 << 0x001A >= 0x00)
		r0->dw0000 = r1;
}

// 0000A054: void UARTCharPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTCharPut(Eq_n * r0, word32 r1)
{
	do
		;
	while (r0->dw0018 << 0x001A < 0x00);
	r0->dw0000 = r1;
}

// 0000A064: void UARTBreakCtl(Register (ptr32 Eq_n) r0, Register word32 r1)
void UARTBreakCtl(Eq_n * r0, word32 r1)
{
	ui32 r3_n = r0->dw002C;
	if (r1 != 0x00)
		r0->dw002C = r3_n | 0x01;
	else
		r0->dw002C = r3_n & ~0x01;
}

// 0000A078: void UARTIntRegister(Register word32 r0, Register word32 r1)
void UARTIntRegister(word32 r0, word32 r1)
{
	r0 != globals->dwA094;
	IntRegister(22, r1);
	IntEnable(22);
}

// 0000A098: void UARTIntUnregister(Register word32 r0)
void UARTIntUnregister(word32 r0)
{
	r0 != globals->dwA0B4;
	IntDisable(22);
	IntUnregister(22);
}

// 0000A0B8: void UARTIntEnable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void UARTIntEnable(Eq_n * r0, ui32 r1)
{
	r0->dw0038 = r1 | r0->dw0038;
}

// 0000A0C0: void UARTIntDisable(Register (ptr32 Eq_n) r0, Register ui32 r1)
void UARTIntDisable(Eq_n * r0, ui32 r1)
{
	r0->dw0038 &= ~(r1 << 0x00);
}

// 0000A0CC: Register (ptr32 Eq_n) UARTIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
Eq_n * UARTIntStatus(Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
		return r0->ptr0040;
	return r0->ptr003C;
}

// 0000A0D8: void UARTIntClear(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1)
void UARTIntClear(Eq_n * r0, Eq_n * r1)
{
	r0->ptr0044 = r1;
}

// 0000A0DC: void CPUcpsie()
void CPUcpsie()
{
	__cps_id();
}

// 0000A0E4: void CPUcpsid()
void CPUcpsid()
{
	__cps_id();
}

// 0000A0EC: void CPUwfi()
void CPUwfi()
{
	__wait_for_interrupt();
}

// 0000A0F4: void I2CMasterInit(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CMasterInit(Eq_n * r0, word32 r1)
{
	r0->dw0020 |= 0x10;
	uint32 r0_n = SysCtlClockGet();
	uint32 r3_n = globals->dwA120;
	uint32 r2_n = globals->dwA124;
	if (r1 == 0x01)
		r3_n = r2_n;
	r0->dw000C = (r0_n - 0x01 + r3_n) /u r3_n - 0x01;
}

// 0000A128: void I2CSlaveInit(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveInit(Eq_n * r0, word32 r1)
{
	*(r0 - 0x07E0) |= 0x20;
	r0->dw0004 = 0x01;
	r0->dw0000 = r1;
}

// 0000A140: void I2CMasterEnable(Register (ptr32 Eq_n) r0)
void I2CMasterEnable(Eq_n * r0)
{
	r0->dw0020 |= 0x10;
}

// 0000A14C: void I2CSlaveEnable(Register (ptr32 Eq_n) r0)
void I2CSlaveEnable(Eq_n * r0)
{
	*(r0 - 0x07E0) |= 0x20;
	r0->dw0004 = 0x01;
}

// 0000A160: void I2CMasterDisable(Register (ptr32 Eq_n) r0)
void I2CMasterDisable(Eq_n * r0)
{
	r0->dw0020 &= ~0x10;
}

// 0000A16C: void I2CSlaveDisable(Register (ptr32 Eq_n) r0)
void I2CSlaveDisable(Eq_n * r0)
{
	r0->dw0004 = 0x00;
	*(r0 - 0x07E0) &= ~0x20;
}

// 0000A180: void I2CIntRegister(Register word32 r1)
void I2CIntRegister(word32 r1)
{
	IntRegister(0x18, r1);
	IntEnable(0x18);
}

// 0000A194: void I2CIntUnregister()
void I2CIntUnregister()
{
	IntDisable(0x18);
	IntUnregister(0x18);
}

// 0000A1A8: void I2CMasterIntEnable(Register (ptr32 Eq_n) r0)
void I2CMasterIntEnable(Eq_n * r0)
{
	r0->dw0010 = 0x01;
}

// 0000A1B0: void I2CSlaveIntEnable(Register (ptr32 Eq_n) r0)
void I2CSlaveIntEnable(Eq_n * r0)
{
	r0->dw000C = 0x01;
}

// 0000A1B8: void I2CMasterIntDisable(Register (ptr32 Eq_n) r0)
void I2CMasterIntDisable(Eq_n * r0)
{
	r0->dw0010 = 0x00;
}

// 0000A1C0: void I2CSlaveIntDisable(Register (ptr32 Eq_n) r0)
void I2CSlaveIntDisable(Eq_n * r0)
{
	r0->dw000C = 0x00;
}

// 0000A1C8: Register (ptr32 Eq_n) I2CMasterIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
Eq_n * I2CMasterIntStatus(Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
	{
		struct Eq_n * r0_n = r0->ptr0018;
		struct Eq_n * r0_n = r0_n;
		if (r0_n != null)
			r0_n = &globals->t0001;
		return r0_n;
	}
	else
	{
		struct Eq_n * r0_n = r0->ptr0014;
		struct Eq_n * r0_n = r0_n;
		if (r0_n != null)
			r0_n = &globals->t0001;
		return r0_n;
	}
}

// 0000A1E0: void I2CSlaveIntStatus(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveIntStatus(Eq_n * r0, word32 r1)
{
	if (r1 != 0x00)
		r0->dw0014 == 0x00;
	else
		r0->dw0010 == 0x00;
}

// 0000A1F8: void I2CMasterIntClear(Register (ptr32 Eq_n) r0)
void I2CMasterIntClear(Eq_n * r0)
{
	r0->dw001C = 0x01;
	r0->dw0018 = 0x01;
}

// 0000A200: void I2CSlaveIntClear(Register (ptr32 Eq_n) r0)
void I2CSlaveIntClear(Eq_n * r0)
{
	r0->dw0018 = 0x01;
}

// 0000A208: void I2CMasterSlaveAddrSet(Register (ptr32 Eq_n) r0, Register ui32 r1, Register ui32 r2)
void I2CMasterSlaveAddrSet(Eq_n * r0, ui32 r1, ui32 r2)
{
	r0->dw0000 = r2 | r1 << 0x01;
}

// 0000A210: void I2CMasterBusy(Register word32 r0)
void I2CMasterBusy(word32 r0)
{
}

// 0000A218: void I2CMasterBusBusy(Register word32 r0)
void I2CMasterBusBusy(word32 r0)
{
}

// 0000A220: void I2CMasterControl(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CMasterControl(Eq_n * r0, word32 r1)
{
	r0->dw0004 = r1;
}

// 0000A224: void I2CMasterErr(Register (ptr32 Eq_n) r0)
void I2CMasterErr(Eq_n * r0)
{
	ui32 r3_n = r0->dw0004;
	if (r3_n << 0x001F < 0x00 || (r3_n & 0x02) == 0x00)
		;
}

// 0000A23C: void I2CMasterDataPut(Register (ptr32 Eq_n) r0, Register ui32 r1)
void I2CMasterDataPut(Eq_n * r0, ui32 r1)
{
	r0->dw0008 = r1;
}

// 0000A240: void I2CMasterDataGet(Register word32 r0)
void I2CMasterDataGet(word32 r0)
{
}

// 0000A244: void I2CSlaveStatus(Register word32 r0)
void I2CSlaveStatus(word32 r0)
{
}

// 0000A248: void I2CSlaveDataPut(Register (ptr32 Eq_n) r0, Register word32 r1)
void I2CSlaveDataPut(Eq_n * r0, word32 r1)
{
	r0->dw0008 = r1;
}

// 0000A24C: void I2CSlaveDataGet(Register word32 r0)
void I2CSlaveDataGet(word32 r0)
{
}

// 0000A5C4: FlagGroup byte memcpy(Register (ptr32 Eq_n) r0, Register (ptr32 Eq_n) r1, Register (ptr32 Eq_n) r2)
byte memcpy(Eq_n * r0, Eq_n * r1, Eq_n * r2)
{
	struct Eq_n * r2_n;
	struct Eq_n * r5_n = r0;
	r2_n = r2;
	if (r2 > &globals->t000F)
	{
		if ((r1 | r0) << 0x001E != 0x00)
		{
			r5_n = r0;
			r2_n = r2;
l0000A630:
			struct Eq_n * r3_n;
			do
			{
				Mem55[r5_n + r3_n:byte] = (byte) (word32) Mem0[r1 + r3_n:byte];
				++r3_n;
			} while (r3_n != r2_n);
l0000A63C:
			word32 sp_n;
			word32 r4_n;
			word32 r5_n;
			word32 r6_n;
			word32 r7_n;
			word32 lr_n;
			word32 r0_n;
			word32 r2_n;
			byte NZCV_n;
			byte ZC_n;
			word32 r1_n;
			word32 r3_n;
			byte NZC_n;
			byte Z_n;
			lr();
			return Z_n;
		}
		struct Eq_n * r4_n = r1;
		struct Eq_n * r3_n;
		struct Eq_n * r5_n = r0 + ((r2 - 0x10 >> 0x04) + 0x01 << 0x04) / 0x0010;
		do
		{
			r3_n->t0000 = r4_n->t0000;
			r3_n->dw0004 = r4_n->dw0004;
			r3_n->dw0008 = r4_n->dw0008;
			r3_n->dw000C = r4_n->dw000C;
			++r3_n;
			++r4_n;
		} while (r5_n != r3_n);
		ui32 r6_n = r2 - 0x10 & ~0x0F;
		r5_n = r0 + (r6_n + 0x10) / 0x0010;
		r1 += (r6_n + 0x10) / 0x0010;
		if ((r2 & 0x0F) > 0x03)
		{
			uint32 r6_n = (r2 & 0x0F) - 0x04;
			int32 r3_n;
			uint32 r4_n = (r6_n >> 0x02) + 0x01;
			do
			{
				r5_n[r3_n / 0x0010] = r1[r3_n / 0x0010];
				r3_n += 0x04;
			} while (r3_n != r4_n << 0x02);
			struct Eq_n * r6_n = r6_n & ~0x03;
			r2_n = r2 & 0x03;
			r1 += r6_n + 0x04;
			r5_n += r6_n + 0x04;
		}
		else
			r2_n = r2 & 0x0F;
	}
	if (r2_n == null)
		goto l0000A63C;
	goto l0000A630;
}

