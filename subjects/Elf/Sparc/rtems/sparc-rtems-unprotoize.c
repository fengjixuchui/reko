// sparc-rtems-unprotoize.c
// Generated by decompiling sparc-rtems-unprotoize
// using Reko decompiler version 0.8.1.0.

#include "sparc-rtems-unprotoize.h"

// 00011498: void _start(Register (ptr32 Eq_n) g1, Register word32 o7, Stack word32 dwArg40)
void _start( * g1, word32 o7, word32 dwArg40)
{
	if (g1 == null)
	{
		atexit(&globals->t16EE4);
		globals->ptr2B40C = fp + 0x44 + ((_init(o7) << 0x02) + 0x04);
		exit(main(fp + 0x44, dwArg44, dwArg48));
	}
	else
		atexit(g1);
}

// 0001150C: Register word32 fn0001150C(Register word32 o7, Register word32 l7)
word32 fn0001150C(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00011514: void __do_global_dtors_aux(Register word32 o7)
void __do_global_dtors_aux(word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x00016660);
	if (*l7_n->ptr0008 != 0x00)
		return;
	word32 ** o2_n = l7_n->ptr0004;
	if (**o2_n != 0x00)
	{
		word32 ** l0_n = o2_n;
		word32 * o0_n = (char *) *o2_n + 0x04;
		while (true)
		{
			*l0_n = o0_n;
			word32 sp_n;
			word32 i0_n;
			word32 o0_n;
			word32 i1_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			fn02800019();
			word32 * o0_n = *l0_n;
			if (*o0_n == 0x00)
				break;
			o0_n = o0_n + 0x01;
		}
	}
	if (l7_n->dw001C == 0x00)
		*l7_n->ptr0008 = 0x01;
	else
	{
		word32 sp_n;
		word32 i0_n;
		word32 o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 l7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		word32 l0_n;
		__deregister_frame_info();
	}
}

// 000115CC: void fini_dummy()
void fini_dummy()
{
}

// 000115D8: void frame_dummy(Register word32 o7)
void frame_dummy(word32 o7)
{
	struct Eq_n * l7_n = fn0001150C(o7, 0x0001659C);
	if (l7_n->dw0018 == 0x00)
		return;
	word32 sp_n;
	word32 i0_n;
	word32 o0_n;
	word32 i1_n;
	word32 o1_n;
	word32 i2_n;
	word32 o2_n;
	word32 i3_n;
	word32 o3_n;
	word32 i4_n;
	word32 o4_n;
	word32 i5_n;
	word32 o5_n;
	word32 i6_n;
	word32 i7_n;
	word32 o7_n;
	word32 l7_n;
	word32 g0_n;
	byte NZVC_n;
	byte Z_n;
	__register_frame_info();
}

// 00011620: void init_dummy()
void init_dummy()
{
}

// 0001162C: Register (ptr32 char) notice(Register (ptr32 char) o0, Stack Eq_n dwArg48, Stack word32 dwArg4C, Stack word32 dwArg50, Stack word32 dwArg54, Stack word32 dwArg58, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out (ptr32 Eq_n) i6Out)
char * notice(char * o0, Eq_n dwArg48, word32 dwArg4C, word32 dwArg50, word32 dwArg54, word32 dwArg58, ptr32 & i1Out, ptr32 & i2Out, Eq_n * & i6Out)
{
	vfprintf(&globals->t2B640, o0, fp + 0x48);
	word32 i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	return o0;
}

// 00011660: Register (ptr32 char) xstrerror(Register (ptr32 char) o0)
char * xstrerror(char * o0)
{
	return strerror(o0);
}

// 00011674: Register Eq_n xmalloc(Register Eq_n o0, Register out (ptr32 int8) i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
Eq_n xmalloc(Eq_n o0, int8 * & i0Out, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	word32 i0_n;
	*i0Out = o0;
	word32 i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	Eq_n o0_n = malloc(o0);
	if (o0_n != 0x00)
		return o0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice("\n%s: virtual memory exceeded\n", dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwLoc1C, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000116B0: Register Eq_n xrealloc(Register Eq_n o0, Register Eq_n o1, Register out (ptr32 Eq_n) i0Out, Register out Eq_n i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
Eq_n xrealloc(Eq_n o0, Eq_n o1, Eq_n * & i0Out, Eq_n & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	Eq_n o0_n;
	Eq_n Z_n;
	word32 i0_n;
	*i0Out = o0;
	word32 i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	if (o0 != 0x00)
	{
		o0_n = realloc(o0, o1);
		Z_n = cond(o0_n);
	}
	else
	{
		o0_n = malloc(o1);
		Z_n = cond(o0_n);
	}
	if (Z_n)
		return o0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice("\n%s: virtual memory exceeded\n", dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwLoc1C, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 00011708: Register Eq_n xfree(Register Eq_n o0)
Eq_n xfree(Eq_n o0)
{
	if (o0 == 0x00)
		return o0;
	free(o0);
}

// 00011728: Register Eq_n savestring(Register Eq_n o0, Register Eq_n o1, Register out ptr32 l0Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i6Out)
Eq_n savestring(Eq_n o0, Eq_n o1, ptr32 & l0Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i6Out)
{
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	Eq_n o0_n = xmalloc((word32) o1 + 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n, o0);
	word32 l0_n;
	*l0Out = o0;
	word32 i0_n;
	*i0Out = o0_n;
	return o0_n;
}

// 0001174C: Register Eq_n savestring2(Register Eq_n o0, Register Eq_n o1, Register word32 o3)
Eq_n savestring2(Eq_n o0, Eq_n o1, word32 o3)
{
	word32 i0_n;
	int32 i1_n;
	Eq_n i2_n;
	word32 i6_n;
	Eq_n o0_n = xmalloc((word32) o1 + o3 + 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n, o0);
	strcpy((word32) o0_n + i1_n, i2_n);
	return o0_n;
}

// 00011780: void fancy_abort()
void fancy_abort()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice("%s: internal abort\n", dwLoc28, dwLoc24, dwLoc20, dwLoc1C, dwLoc18, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000117A0: Register Eq_n dupnstr(Register Eq_n o0, Register Eq_n o1, Register out ptr32 l0Out, Register out (ptr32 int8) i0Out, Register out ptr32 i6Out)
Eq_n dupnstr(Eq_n o0, Eq_n o1, ptr32 & l0Out, int8 * & i0Out, ptr32 & i6Out)
{
	word32 i0_n;
	int32 i1_n;
	word32 i2_n;
	word32 i6_n;
	Eq_n o0_n = xmalloc((word32) o1 + 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
	strncpy(o0_n, o0, i1_n);
	*((word32) o0_n + i1_n) = 0x00;
	word32 l0_n;
	*l0Out = o0;
	word32 i0_n;
	*i0Out = o0_n;
	return o0_n;
}

// 000117CC: Register Eq_n substr(Register Eq_n o0, Register (ptr32 int8) o1)
Eq_n substr(Eq_n o0, int8 * o1)
{
	int32 g2_n = (int32) *o0;
	if (g2_n != 0x00)
	{
		int8 * o3_n = o1;
		int32 g3_n = (int32) *o1;
		if (g3_n == 0x00)
			return o0;
		Eq_n o2_n = o0;
		while ((int32) *o2_n - g3_n == 0x00)
		{
			++o3_n;
			g3_n = (int32) *o3_n;
			if (g3_n == 0x00)
			{
				o0.u0 = (bool) o0.u0 + 0x01;
				return o0;
			}
			o2_n = (word32) o2_n + 0x01;
		}
	}
	else
	{
		o0.u0 = 0x00;
		return o0;
	}
}

// 00011828: Register Eq_n safe_read(Register Eq_n o0, Register Eq_n o1, Register (ptr32 char) o2, Register out Eq_n l0Out, Register out ptr32 l1Out, Register out ptr32 l2Out)
Eq_n safe_read(Eq_n o0, Eq_n o1, char * o2, Eq_n & l0Out, ptr32 & l1Out, ptr32 & l2Out)
{
safe_read_entry:
	Eq_n i1_n = o1
	word32 l2_n
	*l2Out = o0
	Eq_n l0_n
	*l0Out = o2
	word32 l1_n
	*l1Out = 0x0002B400
	goto l00011840
l00011828:
l0001183C:
	i1_n = i1_n + o0_n
l00011840:
	bool NZV_n = (bool) cond(l0_n)
	goto l00011844
l00011840_ds_f:
	Eq_n o0_n = read(o0, i1_n, l0_n)
	branch o0_n >= 0x00 l0001184C_ds_t
	goto l0001184C_ds_f
l00011844:
	branch NZV_n l00011840_ds_t
	goto l00011840_ds_f
l0001184C:
l0001184C_ds_f:
	char * o0_n = globals->ptr2B760
	branch o0_n == (char *) 0x04 l00011864_ds_t
	goto l00011864_ds_f
l0001184C_ds_t:
	branch o0_n != 0x00 l00011874_ds_t
l00011864:
l00011864_ds_f:
	branch l0_n != 0x00 l00011874_ds_t
l00011864_ds_t:
	NZV_n = (bool) cond(l0_n)
	goto l00011844
l00011870:
l00011874:
l00011874_ds_t:
	*l0Out = l0_n - o0_n
	goto l0001183C
l00011874_ds_t:
	*l0Out = l0_n - o0_n
	goto l0001183C
l0001187C:
l00011880:
	return o0_n
safe_read_exit:
}

// 00011888: void safe_write(Register int32 o0, Register (ptr32 void) o1, Register Eq_n o2, Register Eq_n o3)
void safe_write(int32 o0, void, Eq_n o2, Eq_n o3)
{
	void * i1_n = o1;
	Eq_n i2_n = o2;
	if (o2 > 0x00)
	{
		do
		{
			Eq_n o0_n = write(o0, i1_n, i2_n);
			if (o0_n < 0x00)
			{
				if (globals->ptr2B760 != (char *) 0x04)
				{
					word32 l0_n;
					word32 l1_n;
					char * l2_n;
					ui32 l3_n;
					word32 l4_n;
					word32 i0_n;
					word32 i1_n;
					shortpath(0x00, o3, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
					xstrerror(l2_n);
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					notice(l3_n | 0xE0, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
					return;
				}
			}
			else
			{
				i2_n -= o0_n;
				i1_n += o0_n;
			}
		} while (i2_n > 0x00);
	}
}

// 00011914: void save_pointers()
void save_pointers()
{
	up32 o1_n = globals->dw28210;
	globals->dw2B280 = globals->dw281E0;
	globals->dw2B290 = o1_n;
}

// 00011938: void restore_pointers()
void restore_pointers()
{
	up32 o1_n = globals->dw2B290;
	globals->dw281E0 = globals->dw2B280;
	globals->dw28210 = o1_n;
}

// 0001195C: Register int32 is_id_char(Register int32 o0)
int32 is_id_char(int32 o0)
{
	int32 g2_n;
	if (((word32) (o0 & 0xFF)->b2B411 & 0x07) == 0x00)
	{
		g2_n = 0x00;
		if ((o0 & 0xFF) != 0x5F && (o0 & 0xFF) != 0x24)
			return g2_n;
	}
	g2_n = 0x01;
	return g2_n;
}

// 00011998: void usage()
void usage()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice("%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\n", dwLoc28, dwLoc24, dwLoc20, dwLoc1C, dwLoc18, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000119BC: Register Eq_n in_system_include_dir(Register Eq_n o0)
Eq_n in_system_include_dir(Eq_n o0)
{
	if ((int32) *o0 == 0x2F)
	{
		Eq_n i0_n;
		if (globals->t27ED0 != 0x00)
		{
			struct Eq_n * l1_n = &globals->t27ED0;
			Eq_n l0_n = globals->t27ED0;
			while (true)
			{
				if (strncmp(o0, l0_n, strlen(l0_n)) == 0x00)
				{
					if ((int32) Mem0[o0 + strlen(l1_n->dw0000):int8] == 0x2F)
					{
						&i0_n.u0->b0000 = 0x01;
						return i0_n;
					}
					++l1_n;
				}
				else
					++l1_n;
				if (l1_n->dw0000 == 0x00)
					break;
				l0_n = l1_n->dw0000;
			}
		}
		&i0_n.u0->b0000 = 0x00;
		return i0_n;
	}
	else
		abort();
}

// 00011A4C: Register (ptr32 Eq_n) needs_to_be_converted(Register (ptr32 Eq_n) o0)
Eq_n * needs_to_be_converted(Eq_n * o0)
{
	struct Eq_n * o0_n;
	struct Eq_n * g3_n = o0->ptr0004;
	if (g3_n != null)
	{
		int32 g2_n = (int32) g3_n->b0020;
		while (g2_n == 0x00)
		{
			g3_n = g3_n->ptr0000;
			if (g3_n == null)
			{
				o0_n = null;
				return o0_n;
			}
			g2_n = (int32) g3_n->b0020;
		}
		o0_n = (struct Eq_n *) ~0x00;
	}
	else
		o0_n = null;
	return o0_n;
}

// 00011A88: Register Eq_n directory_specified_p(Register Eq_n o0)
Eq_n directory_specified_p(Eq_n o0)
{
	Eq_n i0_n;
	struct Eq_n * l1_n = globals->ptr2B764;
	if (l1_n == null)
	{
		&i0_n.u0->b0000 = 0x00;
		return i0_n;
	}
	else
	{
		Eq_n l0_n = l1_n->t0000;
		while (true)
		{
			if (strncmp(o0, l0_n, strlen(l0_n)) == 0x00)
			{
				if ((int32) Mem0[o0 + strlen(l1_n->t0000):int8] == 0x2F)
				{
					word32 o0_n = o0 + strlen(l1_n->t0000);
					if ((int32) o0_n->b0001 == 0x00)
					{
l00011B1C:
						&i0_n.u0->b0000 = 0x01;
						return i0_n;
					}
					int8 * o2_n = &o0_n->b0001;
					Eq_n Z_n = cond((int32) o0_n->b0001 - 0x2F);
					while (!Z_n)
					{
						++o2_n;
						int32 o0_n = (int32) *o2_n;
						if (o0_n == 0x00)
							goto l00011B1C;
						Z_n = cond(o0_n - 0x2F);
					}
					l1_n = l1_n->ptr0004;
				}
				else
					l1_n = l1_n->ptr0004;
			}
			else
				l1_n = l1_n->ptr0004;
			if (l1_n == null)
			{
				&i0_n.u0->b0000 = 0x00;
				return i0_n;
			}
			l0_n = l1_n->t0000;
		}
	}
}

// 00011B40: Register Eq_n file_excluded_p(Register Eq_n o0)
Eq_n file_excluded_p(Eq_n o0)
{
	Eq_n i0_n;
	Eq_n o0_n = strlen(o0);
	struct Eq_n * l0_n = globals->ptr2B408;
	if (l0_n != null)
	{
		word32 l2_n = o0 + o0_n;
		do
		{
			if (strcmp(l2_n - strlen(l0_n->t0000), l0_n->t0000) == 0x00)
			{
				if ((int32) Mem0[o0_n - strlen(l0_n->t0000) + o0 + -0x01:int8] == 0x2F)
				{
					&i0_n.u0->b0000 = 0x01;
					return i0_n;
				}
				l0_n = l0_n->ptr0004;
			}
			else
				l0_n = l0_n->ptr0004;
		} while (l0_n != null);
		&i0_n.u0->b0000 = 0x00;
	}
	else
		&i0_n.u0->b0000 = 0x00;
	return i0_n;
}

// 00011BC8: Register Eq_n string_list_cons(Register out ptr32 i6Out)
Eq_n string_list_cons(ptr32 & i6Out)
{
	word32 i0_n;
	Eq_n i1_n;
	word32 i2_n;
	word32 i6_n;
	Eq_n o0_n = xmalloc(0x08, out i0_n, out i1_n, out i2_n, out i6_n);
	*o0_n = i0_n;
	*((word32) o0_n + 0x04) = i1_n;
	return o0_n;
}

// 00011BE4: Register (ptr32 Eq_n) visit_each_hash_node(Register (ptr32 Eq_n) o0)
Eq_n * visit_each_hash_node(Eq_n * o0)
{
	struct Eq_n * i0_n = o0;
	if (o0 - (o0 + 0x0200) < 0x00)
	{
		word32 o0_n = o0->dw0004;
		while (true)
		{
			if (o0_n != 0x00)
			{
				l0 = i0_n + 0x01;
				do
				{
					reverse_def_dec_list(i0_n);
					i0_n = i0_n->dw0000;
				} while (i0_n != null);
			}
			else
				l0 = i0_n + 0x01;
			i0_n = l0;
			if (l0 >= (struct Eq_n *) 0x3000)
				break;
			o0_n = l0->dw0004;
		}
	}
	return l0;
}

// 00011C3C: Register Eq_n add_symbol(Register Eq_n o0, Register Eq_n o1, Register out ptr32 i1Out, Register out ptr32 i6Out)
Eq_n add_symbol(Eq_n o0, Eq_n o1, ptr32 & i1Out, ptr32 & i6Out)
{
	&o0->u0->b0000 = 0x00;
	struct Eq_n * l0_n;
	Eq_n i0_n;
	word32 i1_n;
	word32 i6_n;
	Eq_n o0_n = savestring(o1, strlen(o1), out l0_n, out i0_n, out i1_n, out i6_n);
	l0_n->t0004 = o0_n;
	l0_n->dw0008 = 0x00;
	return i0_n;
}

// 00011C6C: Register Eq_n lookup(Register Eq_n o0, Register Eq_n o1, Register out ptr32 spOut, Register out ptr32 l1Out, Register out ptr32 i1Out)
Eq_n lookup(Eq_n o0, Eq_n o1, ptr32 & spOut, ptr32 & l1Out, ptr32 & i1Out)
{
	Eq_n i1_n = o1;
	*i1Out = i1_n;
	ptr32 i6_n = fp;
	word32 l1_n;
	*l1Out = o0;
	ui32 o3_n = 0x00;
	if ((int32) *o1 != 0x00)
	{
		Eq_n o2_n = o1;
		while (true)
		{
			o2_n = (word32) o2_n + 0x01;
			int32 o1_n = (int32) *o2_n;
			if ((int32) *o2_n == 0x00)
				break;
			o3_n += o1_n;
		}
		o3_n += o1_n;
	}
	Eq_n o0_n;
	ui32 o3_n = o3_n & 0x01FF;
	Eq_n i0_n = (word32) o0 + o3_n * 0x0C;
	Eq_n o0_n = *((word32) i0_n + 0x04);
	if (o0_n == 0x00)
		o0_n = i0_n;
	else
	{
		if (strcmp(o0_n, o1) == 0x00)
			goto l00011D34;
		if (*((word32) o0 + o3_n * 0x0C) != 0x00)
		{
			i0_n = *i0_n;
			while (strcmp(*((word32) i0_n + 0x04), o1) != 0x00)
			{
				if (*i0_n == 0x00)
					goto l00011D1C;
				i0_n = *i0_n;
			}
l00011D34:
			word32 sp_n;
			*spOut = i6_n;
			return i0_n;
		}
l00011D1C:
		union Eq_n * i0_n;
		word32 i2_n;
		word32 i6_n;
		o0_n = xmalloc(0x0C, out i0_n, out i1_n, out i2_n, out i6_n);
		*i0_n = (union Eq_n *) o0_n;
	}
	word32 i1_n;
	i0_n = add_symbol(o0_n, i1_n, out i1_n, out i6_n);
	goto l00011D34;
}

// 00011D3C: void free_def_dec(Register (ptr32 Eq_n) o0)
void free_def_dec(Eq_n * o0)
{
	xfree(xfree(o0->t000C));
}

// 00011D58: void unexpand_if_needed(Register Eq_n o0)
void unexpand_if_needed(Eq_n o0)
{
	Eq_n i0_n = o0;
	word32 i1_n = 0x00;
	if (globals->t27F50 == 0x00)
	{
		&globals->t27F54.u0->b0000 = 0x0400;
		word32 i2_n;
		word32 i6_n;
		globals->t27F50 = xmalloc(0x0400, out i0_n, out i1_n, out i2_n, out i6_n);
	}
	Eq_n l1_n;
	if ((int32) *i0_n == 0x0A)
	{
		l1_n = globals->t27F50;
		goto l00011EC8;
	}
	l1_n = globals->t27F50;
	Eq_n o0_n = globals->t16F14;
l00011DA0:
	if (o0_n != 0x00)
	{
		struct Eq_n * l4_n = &globals->t16F14;
		Eq_n l0_n = globals->t16F14;
		while (true)
		{
			Eq_n o0_n = strlen(l0_n);
			if ((int32) (*i0_n - *l0_n) == 0x00)
			{
				if (strncmp(i0_n, l0_n, o0_n) == 0x00)
				{
					if (is_id_char((int32) Mem0[i0_n + o0_n:int8]) == 0x00)
					{
						Eq_n o0_n = strlen(l4_n->dw0004);
						Eq_n o1_n = globals->t27F50;
						Eq_n o2_n = globals->t27F54;
						i1_n = 0x01;
						if (l1_n + o0_n - o1_n - o2_n >= 0x00)
						{
							Eq_n o2_n = (word32) o0_n + (o2_n << 0x01);
							globals->t27F54 = o2_n;
							word32 i2_n;
							word32 i6_n;
							Eq_n o0_n = xrealloc(o1_n, o2_n, out i0_n, out i1_n, out i2_n, out i6_n);
							globals->t27F50 = o0_n;
							l1_n = o0_n + (l1_n - o1_n);
						}
						strcpy(l1_n, l4_n->dw0004);
						l1_n += o0_n;
						i0_n += o0_n;
						goto l00011EB8;
					}
					++l4_n;
				}
				else
					++l4_n;
			}
			else
				++l4_n;
			if (l4_n->dw0000 == 0x00)
				break;
			l0_n = l4_n->dw0000;
		}
	}
	word32 o0_n;
	Eq_n o1_n = globals->t27F50;
	int32 l0_n = l1_n - o1_n;
	if (l0_n - globals->t27F54 == 0x00)
	{
		globals->t27F54 = l0_n << 0x01;
		word32 i2_n;
		word32 i6_n;
		Eq_n o0_n = xrealloc(o1_n, l0_n << 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
		globals->t27F50 = o0_n;
		l1_n = (word32) o0_n + l0_n;
		o0_n = (word32) *i0_n;
	}
	else
		o0_n = (word32) *i0_n;
	*l1_n = (byte) o0_n;
	i0_n = (word32) i0_n + 0x01;
	++l1_n;
l00011EB8:
	if ((int32) *i0_n == 0x0A)
	{
l00011EC8:
		Eq_n o2_n = globals->t27F50;
		Eq_n o1_n = globals->t27F54;
		if (l1_n - ((word32) o2_n - 0x02) - o1_n >= 0x00)
		{
			globals->t27F54 = o1_n << 0x01;
			word32 i0_n;
			word32 i2_n;
			word32 i6_n;
			Eq_n o0_n = xrealloc(o2_n, o1_n << 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
			globals->t27F50 = o0_n;
			l1_n = o0_n + (l1_n - o2_n);
		}
		*l1_n = 0x0A;
		size_t l1_n = l1_n + 0x01;
		if (i1_n == 0x00)
			*l1_n = (Eq_n) 0x00;
		else
		{
			*l1_n = (Eq_n) 0x00;
			Eq_n o0_n = globals->t27F50;
			word32 l0_n;
			word32 i0_n;
			word32 i1_n;
			word32 i6_n;
			savestring(o0_n, l1_n - o0_n, out l0_n, out i0_n, out i1_n, out i6_n);
		}
		return;
	}
	o0_n = globals->t16F14;
	goto l00011DA0;
}

// 00011F34: Register Eq_n abspath(Register Eq_n o0, Register Eq_n o1, Register out ptr32 spOut, Register out ptr32 l0Out, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i6Out)
Eq_n abspath(Eq_n o0, Eq_n o1, ptr32 & spOut, ptr32 & l0Out, ptr32 & i1Out, Eq_n * & i6Out)
{
	Eq_n i0_n = o0;
	if (o0 == 0x00)
		i0_n = globals->t2B270;
	struct Eq_n * o2_n;
	word32 sp_n = fp + ~0x77 - ((strlen(i0_n) + strlen(o1)) + 0x09 & ~0x07);
	if ((int32) *o1 != 0x2F)
	{
		ui32 o1_n = (word32) *i0_n;
		sp_n->b0060 = (byte) o1_n;
		o2_n = (struct Eq_n *) &sp_n->b0061;
		if (o1_n << 0x18 != 0x00)
		{
			byte * i0_n = (word32) i0_n + 0x01;
			while (true)
			{
				ui32 o0_n = (word32) *i0_n;
				o2_n->b0000 = (byte) o0_n;
				++i0_n;
				if (o0_n << 0x18 == 0x00)
					break;
				++o2_n;
			}
			++o2_n;
		}
		o2_n->bFFFFFFFF = 0x2F;
	}
	else
		o2_n = (struct Eq_n *) &sp_n->b0060;
	ui32 o0_n = (word32) *o1;
	o2_n->b0000 = (byte) o0_n;
	byte * i0_n = (word32) o1 + 0x01;
	byte * o2_n = o2_n + 0x01;
	if (o0_n << 0x18 != 0x00)
	{
		while (true)
		{
			ui32 o0_n = (word32) *i0_n;
			*o2_n = (byte) o0_n;
			++i0_n;
			if (o0_n << 0x18 == 0x00)
				break;
			++o2_n;
		}
	}
	struct Eq_n * o2_n = &sp_n->b0061;
	if ((int32) sp_n->b0061 != 0x00)
	{
		struct Eq_n * o1_n = &sp_n->b0061;
		Eq_n Z_n = cond((int32) sp_n->b0061 - 0x2F);
l00012024:
		Eq_n Z_n;
		if (!Z_n)
		{
			word32 o3_n = (word32) o1_n->b0000;
			if ((int32) o2_n->bFFFFFFFF == 0x2F)
			{
				o1_n = &o1_n->b0001;
				goto l00012110;
			}
			Z_n = cond(o3_n - 0x2E);
		}
		else
		{
			word32 o3_n = (word32) o1_n->b0000;
			Z_n = cond(o3_n - 0x2E);
		}
		word32 o0_n;
		if (Z_n)
		{
			o0_n = (word32) o1_n->b0000;
			goto l00012104;
		}
		if ((int32) o2_n->bFFFFFFFF != 0x2F)
		{
			o0_n = (word32) o1_n->b0000;
			goto l00012104;
		}
		int32 o0_n = (int32) o1_n->b0001;
		if (o0_n != 0x00)
		{
			if (o0_n == 0x2F)
			{
				o1_n = &o1_n->b0002;
				goto l00012110;
			}
			if (o0_n == 0x2E)
			{
				int32 o0_n = (int32) o1_n->b0002;
				if (o0_n == 0x00 || o0_n == 0x2F)
				{
					struct Eq_n * o0_n;
					if (o0_n == 0x2F)
						o0_n = o1_n + 0x01;
					else
						o0_n = &o1_n->b0002;
					int8 * o2_n = (char *) o2_n - 0x02;
					o1_n = o0_n;
					while (true)
					{
						Eq_n g0_n = o2_n - &sp_n->b0060;
						Eq_n C_n = cond(g0_n);
						if (g0_n < 0x00)
							break;
						if ((int32) *o2_n == 0x2F)
						{
							C_n = cond(o2_n - &sp_n->b0060);
							break;
						}
						o2_n += -0x01;
					}
					if (!C_n)
					{
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice("%s: invalid file name: %s\n", dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
						exit(33);
					}
					o2_n = (struct Eq_n *) (o2_n + 0x01);
					o2_n->b0000 = 0x00;
l00012110:
					int32 o0_n = (int32) o1_n->b0000;
					if (o0_n == 0x00)
						goto l00012120;
					Z_n = cond(o0_n - 0x2F);
					goto l00012024;
				}
				o0_n = (word32) o1_n->b0000;
			}
			else
				o0_n = (word32) o1_n->b0000;
l00012104:
			o2_n->b0000 = (byte) o0_n;
			o1_n = &o1_n->b0001;
			++o2_n;
			goto l00012110;
		}
	}
l00012120:
	if ((int32) o2_n->bFFFFFFFF == 0x2F)
	{
		o2_n->b0000 = 0x00;
		o2_n = &o2_n->bFFFFFFFF;
		o2_n->b0000 = 0x00;
	}
	else
		o2_n->b0000 = 0x00;
	word32 sp_n;
	*spOut = i6_n;
	word32 l0_n;
	word32 i0_n;
	word32 i1_n;
	word32 i6_n;
	return savestring(&sp_n->b0060, o2_n - &sp_n->b0060, out l0_n, out i0_n, out i1_n, out i6_n);
}

// 0001214C: Register Eq_n shortpath(Register Eq_n o0, Register Eq_n o1, Register out Eq_n l0Out, Register out ptr32 l1Out, Register out (ptr32 Eq_n) l2Out, Register out ptr32 l3Out, Register out (ptr32 Eq_n) l4Out, Register out ptr32 i0Out, Register out ptr32 i1Out)
Eq_n shortpath(Eq_n o0, Eq_n o1, Eq_n & l0Out, ptr32 & l1Out, Eq_n * & l2Out, ptr32 & l3Out, Eq_n * & l4Out, ptr32 & i0Out, ptr32 & i1Out)
{
	Eq_n o0_n = strlen(o1);
	word32 sp_n;
	word32 i1_n;
	word32 i6_n;
	int8 * l0_n;
	abspath(o0, o1, out sp_n, out l0_n, out i1_n, out i6_n);
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	Eq_n i0_n;
	Eq_n o0_n = xmalloc(o0_n, out i0_n, out i1_n, out i2_n, out i6_n);
	ui32 l2_n = 0x00;
	*l2Out = l2_n;
	word32 l3_n;
	*l3Out = o0_n;
	int32 o1_n = (int32) *l0_n;
	word32 l4_n;
	*l4Out = o0_n;
	Eq_n l1_n = o0_n;
	*l1Out = l1_n;
	while (true)
	{
		int32 o0_n;
		if (o1_n == 0x00)
			break;
		if (o1_n - (int32) (*i0_n) != 0x00)
		{
			o0_n = (int32) *l0_n;
			goto l000121B8;
		}
		++l0_n;
		*l0Out = l0_n;
		o1_n = (int32) *l0_n;
		i0_n = (word32) i0_n + 0x01;
	}
	o0_n = (int32) *l0_n;
l000121B8:
	Eq_n Z_n;
	Eq_n i0_n;
	if (o0_n == 0x00)
	{
		ui32 o1_n = (word32) *i0_n;
		int32 o0_n = o1_n << 0x18 >> 0x18;
		if (o0_n == 0x00 || o0_n == 0x2F)
		{
			if (o0_n == 0x00)
				*i0Out = 0x00017168;
			else
				*i0Out = (word32) i0_n + 0x01;
			return i0_n;
		}
		Z_n = cond(o1_n);
	}
	else
	{
		word32 o1_n = (word32) *i0_n;
		Z_n = cond(o1_n);
	}
	int32 o0_n;
	if (!Z_n)
	{
		while (true)
		{
			l0_n += -0x01;
			if ((int32) *l0_n == 0x2F)
				break;
			i0_n = (word32) i0_n - 0x01;
		}
		ptr32 i0_n = (word32) i0_n - 0x01;
		++l0_n;
		i0_n = i0_n + 0x01;
		l2_n = 0x01;
l00012238:
		o0_n = (int32) *l0_n;
	}
	else
		o0_n = (int32) *l0_n;
	if (o0_n == 0x00)
	{
		uint32 l0_n = (word32) strlen(i0_n) + l2_n * 0x03;
		*l0Out = l0_n;
		if (l0_n - o0_n >= 0x00)
		{
			word32 l2_n;
			*l2Out = l2_n + ~0x00;
		}
		else
		{
			ui32 l2_n = l2_n + ~0x00 + ~0x00;
			*l2Out = l2_n;
			uint32 o3_n;
			if (l2_n == ~0x00)
			{
				o3_n = o0_n + o0_n;
l000122B8:
				while (o3_n - l1_n > 0x00)
				{
					ui32 o0_n = (word32) *i0_n;
					*l1_n = (byte) o0_n;
					i0_n = (word32) i0_n + 0x01;
					if (o0_n << 0x18 == 0x00)
					{
						word32 l1_n = l1_n + 0x01;
						word32 l1_n;
						*l1Out = &l1_n->bFFFFFFFE + 0x01;
						if ((int32) l1_n->bFFFFFFFE == 0x2F)
							l1_n->bFFFFFFFE = 0x00;
						*i0Out = o0_n;
						return i0_n;
					}
					*l1Out = l1_n + 0x01;
				}
				*i0Out = i1_n;
				return i0_n;
			}
			o3_n = o0_n + o0_n;
			while (o3_n - (l1_n + 0x03) >u 0x00)
			{
				l2_n += ~0x00;
				*l2Out = l2_n;
				*l1_n = 0x2E;
				struct Eq_n * l1_n = (word32) l1_n + 0x01;
				l1_n->b0000 = 0x2E;
				l1_n->b0001 = 0x2F;
				if (l2_n == 0x00)
				{
					*l1Out = &l1_n->b0001 + 0x01;
					goto l000122B8;
				}
				*l1Out = &l1_n->b0001 + 0x01;
			}
			word32 l2_n;
			*l2Out = l2_n + 0x00;
		}
		*i0Out = i1_n;
		return i0_n;
	}
	word32 o1_n = (word32) *l0_n;
	if (o1_n == 0x2F)
	{
		++l0_n;
		++l2_n;
	}
	else
		++l0_n;
	goto l00012238;
}

// 00012304: Register Eq_n find_file(Register Eq_n o0, Register out ptr32 l2Out, Register out ptr32 l3Out, Register out ptr32 i0Out, Register out ptr32 i1Out)
Eq_n find_file(Eq_n o0, ptr32 & l2Out, ptr32 & l3Out, ptr32 & i0Out, ptr32 & i1Out)
{
	*l2Out = l2;
	*l3Out = l3;
	word32 sp_n;
	Eq_n l1_n;
	word32 i1_n;
	struct Eq_n * o0_n = lookup(164416, o0, out sp_n, out l1_n, out i1_n);
	Eq_n i0_n = o0_n->t0008;
	*i0Out = i0_n;
	if (i0_n != 0x00)
		return i0_n;
	Eq_n l4_n;
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	struct Eq_n * i6_n;
	Eq_n o0_n = xmalloc(0x0C, out i0_n, out i1_n, out i2_n, out i6_n);
	if (i1_n != 0x00)
	{
		l4_n = o0_n;
		&i6_n->tFFFFFFA8.u0->b0000 = 0x00;
	}
	else
	{
		l4_n = o0_n;
		if (stat(l1_n, (char *) i6_n - 0x0098) != ~0x00)
		{
			o0_n->t0008 = o0_n;
l000123B4:
			*l4_n = o0_n;
			*((word32) l4_n + 0x04) = 0x00;
			*((word32) l4_n + 0x08) = i6_n->tFFFFFFA8;
			*i0Out = l4_n;
			return i0_n;
		}
		char * l0_n;
		word32 l1_n;
		char * l2_n;
		word32 l3_n;
		word32 i0_n;
		word32 i1_n;
		shortpath(0x00, l1_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
		xstrerror(l2_n);
		word32 i1_n;
		word32 i2_n;
		Eq_n i0_n = notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
		i6_n->tFFFFFFA8 = i0_n;
	}
	o0_n->t0008 = l4_n;
	goto l000123B4;
}

// 000123D0: void aux_info_corrupted()
void aux_info_corrupted()
{
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice("\n%s: fatal error: aux info file corrupted at line %d\n", dwLoc28, dwLoc24, dwLoc20, dwLoc1C, dwLoc18, out i1_n, out i2_n, out i6_n);
	exit(33);
}

// 000123F8: Register word32 check_aux_info(Register word32 o0, Register out ptr32 i1Out, Register out ptr32 i6Out)
word32 check_aux_info(word32 o0, ptr32 & i1Out, ptr32 & i6Out)
{
	word32 i1_n;
	*i1Out = o1;
	word32 i6_n;
	*i6Out = fp;
	if (o0 != 0x00)
		return o0;
	aux_info_corrupted();
}

// 00012418: Register (ptr32 Eq_n) find_corresponding_lparen(Register (ptr32 Eq_n) o0)
Eq_n * find_corresponding_lparen(Eq_n * o0)
{
	int8 * o0_n = &o0->bFFFFFFFF.bFFFFFFFF;
	word32 g3_n = 0x01;
	int32 g2_n = (int32) o0->bFFFFFFFF;
l00012424:
	if (g2_n != 0x28)
	{
		int32 g0_n = g2_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = o0_n;
l00012448:
			if (g3_n == 0x00)
				return o0_n + 0x01;
			g2_n = (int32) *o0_n;
			goto l00012424;
		}
		++g3_n;
	}
	else
		g3_n += ~0x00;
	o0_n += -0x01;
	goto l00012448;
}

// 0001245C: void referenced_file_is_newer(Register (ptr32 int8) o0)
void referenced_file_is_newer(int8 * o0)
{
	int8 * l1_n;
	word32 i1_n;
	word32 i6_n;
	word32 i1_n;
	word32 i6_n;
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (*o0) ^ 0x2F) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x2A) > 0x00), out i1_n, out i6_n)[0x02] ^ 0x20) > 0x00), out i1_n, out i6_n);
	if ((int32) i0_n[0x03] != 0x3A)
	{
		l1_n = (int8 *) (i0_n + 0x04);
		while ((int32) *l1_n != 0x3A)
			++l1_n;
	}
	else
		l1_n = (int8 *) (i0_n + 0x03);
	int32 l1_n = l1_n - (i0_n + 0x03);
	struct Eq_n * sp_n = fp + ~0x6F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n + 0x03, l1_n);
	Eq_n o0_n = globals->t28190;
	sp_n->a0060[l1_n] = 0x00;
	word32 sp_n;
	word32 l0_n;
	word32 i1_n;
	word32 i6_n;
	word32 l2_n;
	word32 l3_n;
	word32 i0_n;
	int32 i1_n;
	int32 o1_n = find_file(abspath(o0_n, sp_n->a0060, out sp_n, out l0_n, out i1_n, out i6_n), out l2_n, out l3_n, out i0_n, out i1_n)->dw0008;
}

// 0001251C: void save_def_or_dec()
void save_def_or_dec()
{
	int8 * i0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	xmalloc(44, out i0_n, out i1_n, out i2_n, out i6_n);
	word32 i1_n;
	word32 i6_n;
	word32 i1_n;
	word32 i6_n;
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (*i0_n) ^ 0x2F) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x2A) > 0x00), out i1_n, out i6_n)[0x02] ^ 0x20) > 0x00), out i1_n, out i6_n);
	int8 * i0_n = i0_n + 0x03;
	if ((int32) i0_n[0x03] != 0x3A)
	{
		i0_n = (int8 *) (i0_n + 0x04);
		while ((int32) *i0_n != 0x3A)
			++i0_n;
	}
	Eq_n i0_n;
	int32 l1_n = i0_n - (i0_n + 0x03);
	struct Eq_n * sp_n = fp + ~0x7F - (l1_n + 0x08 & ~0x07);
	strncpy(sp_n->a0060, i0_n + 0x03, l1_n);
	Eq_n o0_n = globals->t28190;
	sp_n->a0060[l1_n] = 0x00;
	word32 sp_n;
	word32 l0_n;
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * l2_n;
	Eq_n l3_n;
	Eq_n i0_n;
	word32 i1_n;
	struct Eq_n * o0_n = find_file(abspath(o0_n, sp_n->a0060, out sp_n, out l0_n, out i1_n, out i6_n), out l2_n, out l3_n, out i0_n, out i1_n);
	l2_n->ptr0004 = o0_n;
	if ((int32) *i0_n != 0x3A)
	{
		i0_n = (word32) i0_n + 0x01;
		while ((int32) *i0_n != 0x3A)
			i0_n = (word32) i0_n + 0x01;
	}
	else
		i0_n = i0_n;
	word32 o2_n;
	int32 l0_n = i0_n - i0_n;
	strncpy(l3_n, i0_n, l0_n);
	*((word32) l3_n + l0_n) = 0x00;
	l2_n->dw0008 = atoi(l3_n);
	word32 o1_n = (word32) *((word32) i0_n + 0x01);
	if ((o1_n + ~0x4D & 0xFF) > 0x01)
	{
		o2_n = 0x00;
		if (o1_n != 0x49)
		{
l00012648:
			word32 o2_n;
			word32 i1_n;
			word32 i6_n;
			struct Eq_n * i0_n = check_aux_info(o2_n, out i1_n, out i6_n);
			l2_n->b0020 = (byte) (0x01 - (((int32) i0_n->b0000 ^ 0x4E) > 0x00));
			int32 o0_n = (int32) i0_n[0x01];
			if (o0_n != 0x43)
			{
				o2_n = 0x00;
				if (o0_n != 0x46)
				{
l00012688:
					word32 i1_n;
					word32 i6_n;
					struct Eq_n * i0_n = check_aux_info(o2_n, out i1_n, out i6_n);
					if ((int32) i0_n->b0000 != 0x46 && i1_n == 0x00)
						l2_n->dw0014 = 0x00;
					else
						l2_n->dw0014 = 0x01;
					word32 o0_n;
					word32 i1_n;
					word32 i6_n;
					word32 i1_n;
					word32 i6_n;
					word32 i1_n;
					word32 i6_n;
					word32 i1_n;
					word32 i6_n;
					struct Eq_n * i0_n = check_aux_info(0x01 - ((((word32) (check_aux_info)(0x01 - ((((word32) (check_aux_info)(0x01 - ((((word32) (check_aux_info)(0x01 - ((((word32) i0_n[0x01] << 0x18) >> 0x18 ^ 0x20) > 0x00), out i1_n, out i6_n)[0x01] << 0x18) >> 0x18 ^ 0x2A) > 0x00), out i1_n, out i6_n)[0x01] << 0x18) >> 0x18 ^ 0x2F) > 0x00), out i1_n, out i6_n)[0x01] << 0x18) >> 0x18 ^ 0x20) > 0x00), out i1_n, out i6_n);
					word32 sp_n = sp_n + ~0x0B;
					if (strncmp(i0_n + 0x01, 94664, 0x06) != 0x00)
					{
						sp_n = sp_n + ~0x0F;
						if (strncmp(i0_n + 0x01, 0x000171D0, 0x06) != 0x00)
						{
							o0_n = 0x00;
l00012780:
							word32 i1_n;
							word32 i6_n;
							int8 * i0_n = check_aux_info(o0_n, out i1_n, out i6_n) + 0x07;
							while ((int32) *i0_n != 0x3B)
								++i0_n;
							ui32 l0_n;
							word32 i0_n;
							word32 i6_n;
							l2_n->t000C = dupnstr(i0_n + 0x01, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
							struct Eq_n * i0_n = i0_n + ~0x00;
							while (true)
							{
								int32 o0_n;
								if (i0_n - l0_n == 0x00)
									break;
								int32 o0_n = (int32) i0_n->bFFFFFFFF;
								if (o0_n != 0x20)
								{
									if (o0_n == 0x09)
									{
										i0_n = &i0_n->bFFFFFFFF;
										continue;
									}
									else
									{
										o0_n = (int32) i0_n->b0000;
										goto l000127E4;
									}
								}
								i0_n = &i0_n->bFFFFFFFF;
							}
							o0_n = (int32) i0_n->b0000;
l000127E4:
							if (o0_n != 0x29)
							{
l00012AC0:
								free_def_dec(l2_n);
							}
							l2_n->dw001C = 0x00;
							struct Eq_n * o0_n = find_corresponding_lparen(i0_n);
							++l2_n->dw001C;
							if ((int32) o0_n->bFFFFFFFE == 0x29)
							{
								word32 i1_n;
								word32 i6_n;
								check_aux_info(0x01 - (((int32) o0_n->bFFFFFFFD ^ 0x29) > 0x00), out i1_n, out i6_n);
							}
							word32 i1_n;
							word32 i6_n;
							struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) o0_n->bFFFFFFFF ^ 0x20) > 0x00), out i1_n, out i6_n);
							while (is_id_char((int32) i0_n->b0000) != 0x00)
								i0_n = (struct Eq_n *) ((char *) i0_n - 0x01);
							word32 o0_n;
							Eq_n i0_n = i0_n + 0x01;
							int32 l1_n = &o0_n->bFFFFFFFF - i0_n;
							struct Eq_n * sp_n = sp_n - (l1_n + 0x08 & ~0x07);
							strncpy(sp_n->a0060, i0_n, l1_n);
							sp_n->a0060[l1_n] = 0x00;
							word32 sp_n;
							word32 l1_n;
							struct Eq_n * i1_n;
							struct Eq_n * o0_n = lookup(0x00029A40, sp_n->a0060, out sp_n, out l1_n, out i1_n);
							l2_n->ptr0010 = o0_n;
							Eq_n o2_n = o0_n->t0008;
							if (o2_n != 0x00)
							{
								int32 o1_n = l2_n->dw0008;
								while (true)
								{
									if (o1_n - *((word32) o2_n + 0x08) == 0x00)
									{
										if (l2_n->ptr0004 - *((word32) o2_n + 0x04) == 0x00)
										{
											if (strcmp(l2_n->t000C, *((word32) o2_n + 0x0C)) != 0x00)
											{
												word32 i1_n;
												word32 i2_n;
												word32 i6_n;
												notice("%s:%d: declaration of function `%s' takes different forms\n", dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
												exit(33);
											}
											goto l00012AC0;
										}
										o2_n = *((word32) o2_n + 0x0018);
									}
									else
										o2_n = *((word32) o2_n + 0x0018);
									if (o2_n == 0x00)
										break;
									o1_n = l2_n->dw0008;
								}
								o0_n = l2_n->dw0014;
							}
							else
								o0_n = l2_n->dw0014;
							int32 o0_n;
							&l2_n->t0024.u0->b0000 = 0x00;
							if (o0_n != 0x00)
							{
								l2_n->dw0028 = 0x00;
								ptr32 i0_n;
								word32 i1_n;
								word32 i6_n;
								word32 i1_n;
								word32 i6_n;
								word32 i1_n;
								word32 i6_n;
								word32 i1_n;
								word32 i6_n;
								word32 i1_n;
								word32 i6_n;
								struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) (check_aux_info)(0x01 - (((int32) i1_n->b0001 ^ 0x20) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x2F) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x2A) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x20) > 0x00), out i1_n, out i6_n)[0x01] ^ 0x28) > 0x00), out i1_n, out i6_n);
								if ((int32) i0_n[0x01] != 0x29)
								{
									int8 * i0_n = i0_n + 0x02;
									while ((int32) *i0_n != 0x29)
										++i0_n;
									i0_n = i0_n + 0x01;
								}
								else
									i0_n = i0_n + 0x02;
								word32 l0_n;
								struct Eq_n * i0_n;
								word32 i6_n;
								l2_n->t0024 = dupnstr(i0_n + 0x01, i0_n + ~0x00 - (i0_n + 0x01), out l0_n, out i0_n, out i6_n);
								word32 i1_n;
								word32 i6_n;
								struct Eq_n * i0_n = check_aux_info(0x01 - (((int32) i0_n->b0001 ^ 0x20) > 0x00), out i1_n, out i6_n);
								if ((int32) i0_n[0x01] != 0x2A)
								{
									struct Eq_n * i0_n = i0_n + 0x02;
									while (true)
									{
										while ((int32) i0_n->b0000 != 0x2A)
											++i0_n;
										if ((int32) i0_n[0x01] == 0x2F)
											break;
										++i0_n;
									}
									word32 i1_n;
									word32 i6_n;
									word32 l0_n;
									word32 i0_n;
									word32 i6_n;
									dupnstr(i0_n + 0x01, check_aux_info(0x01 - (((int32) i0_n->bFFFFFFFF ^ 0x20) > 0x00), out i1_n, out i6_n) - (i0_n + 0x01), out l0_n, out i0_n, out i6_n);
								}
								word32 i1_n;
								word32 i6_n;
								check_aux_info(0x01 - (((int32) i0_n[0x02] ^ 0x2F) > 0x00), out i1_n, out i6_n);
								l2_n->dw0028 = 94744;
								if ((int32) l2_n->b0020 != 0x00)
									return;
								if ((int32) *l2_n->t0024 != 0x00)
								{
									o0_n = (int32) l2_n->b0020;
l00012AB4:
									if (o0_n != 0x00)
										return;
									goto l00012AC0;
								}
								l2_n->b0020 = 0x01;
							}
							else
								l2_n->dw0028 = 0x00;
							o0_n = (int32) l2_n->b0020;
							goto l00012AB4;
						}
					}
					o0_n = 0x01;
					goto l00012780;
				}
			}
			o2_n = 0x01;
			goto l00012688;
		}
	}
	o2_n = 0x01;
	goto l00012648;
}

// 00012B64: Register (ptr32 Eq_n) munge_compile_params(Register Eq_n o0, Register out ptr32 i0Out, Register out ptr32 i6Out)
Eq_n * munge_compile_params(Eq_n o0, ptr32 & i0Out, ptr32 & i6Out)
{
	struct Eq_n * sp_n = fp + ~0x73 - ((strlen(o0) << 0x02) + 0x27 & ~0x07);
	sp_n->a0060[0x00] = globals->dw27F24;
	Eq_n i0_n;
	*i0Out = o0;
	word32 i6_n;
	*i6Out = fp;
	ui32 l0_n = 0x01;
	do
	{
		ui32 o3_n;
		int32 g2_n = l0_n << 0x02;
		if (((word32) ((word32) *i0_n + 177169) & 0x08) != 0x00)
		{
			o3_n = l0_n + 0x01;
			*i0Out = (word32) i0_n + 0x01;
			while (((word32) ((word32) *i0_n + 177169) & 0x08) != 0x00)
				*i0Out = (word32) i0_n + 0x01;
		}
		else
			o3_n = l0_n + 0x01;
		if ((int32) *i0_n == 0x00)
			goto l00012D00;
		struct Eq_n * o1_n = (word32) *i0_n;
		Eq_n i0_n;
		if (((word32) o1_n->b2B411 & 0x08) == 0x00)
		{
			*i0Out = (word32) i0_n + 0x01;
			while ((int32) *i0_n != 0x00)
			{
				struct Eq_n * o1_n = (word32) *i0_n;
				if (((word32) o1_n->b2B411 & 0x08) != 0x00)
					break;
				*i0Out = (word32) i0_n + 0x01;
			}
		}
		else
			i0_n = i0_n;
		if ((int32) *i0_n == 0x2D && ((word32) (*((word32) i0_n + 0x01)) + ~0x4E << 0x18) >> 0x18 < 0x20)
			return sp_n;
		ui32 l0_n;
		word32 i6_n;
		Eq_n o0_n = dupnstr(i0_n, i0_n - i0_n, out l0_n, out i0_n, out i6_n);
		sp_n->a0060[l0_n] = (word32) o0_n;
		l0_n = l0_n + 0x01;
		g2_n = l0_n + 0x01 << 0x02;
	} while ((int32) *i0_n != 0x00);
	o3_n = l0_n + 0x02;
l00012D00:
	globals->dw27F48 = o3_n;
	sp_n->a0060[g2_n / 0x04] = 0x00017220;
	ui32 l0_n = o3_n + 0x01;
	globals->dw27F44 = l0_n + 0x03;
	sp_n->a0060[o3_n] = 0x00;
	sp_n->a0060[l0_n] = 0x00017230;
	sp_n->a0060[l0_n + 0x01] = 94776;
	sp_n->a0060[l0_n + 0x02] = 94784;
	sp_n->a0060[l0_n + 0x03] = 0x00;
	sp_n->a0060[l0_n + 0x04] = 0x00;
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	struct Eq_n * i6_n;
	Eq_n o0_n = xmalloc(l0_n + 0x06 << 0x02, out i0_n, out i1_n, out i2_n, out i6_n);
	globals->t27F3C = o0_n;
	memcpy(o0_n, sp_n->a0060, l0_n + 0x05 << 0x02);
	return i6_n;
}

// 00012E2C: Register Eq_n gen_aux_info_file(Register Eq_n o0, Register out ptr32 spOut, Register out ptr32 l0Out, Register out ptr32 l1Out, Register out ptr32 l2Out, Register out (ptr32 char) l4Out, Register out (ptr32 char) i0Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
Eq_n gen_aux_info_file(Eq_n o0, ptr32 & spOut, ptr32 & l0Out, ptr32 & l1Out, ptr32 & l2Out, char * & l4Out, char * & i0Out, ptr32 & i2Out, ptr32 & i6Out)
{
	Eq_n o1_n;
	ptr32 sp_n = fp + ~0x87;
	if (globals->dw27F44 == 0x00)
	{
		Eq_n i0_n;
		word32 i6_n;
		sp_n = munge_compile_params(94744, out i0_n, out i6_n);
		o1_n = i0_n;
	}
	else
		o1_n = o0;
	word32 l0_n;
	word32 l1_n;
	struct Eq_n * l2_n;
	word32 l3_n;
	word32 l4_n;
	word32 i0_n;
	word32 i1_n;
	Eq_n o0_n = shortpath(0x00, o1_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
	*((word32) globals->t27F3C + l2_n->dw0344 * 0x04) = o0_n;
	word32 o0_n = savestring2(o0_n, strlen(o0_n), 0x02);
	word32 o1_n = globals->dw27F2C;
	*((word32) globals->t27F3C + globals->dw27F48 * 0x04) = o0_n;
	struct Eq_n * sp_n = sp_n + ~0x03;
	if (o1_n != 0x00)
	{
		struct Eq_n * l0_n;
		Eq_n l1_n;
		struct Eq_n * i0_n;
		word32 i6_n;
		choose_temp_base(out l0_n, out l1_n, out i0_n, out i6_n);
		Eq_n o0_n = *i0_n->ptr033C;
		char * o2_n = l0_n->ptr0150;
		sp_n->dw005C = 0x07;
		struct Eq_n * l0_n;
		struct Eq_n * i6_n;
		if (pexecute(o0_n, o2_n, i6_n + ~0x13, i6_n + ~0x17, l1_n, dwArg44, dwArg48, dwArg4C, dwArg54, dwArg58, dwArg5C, out l0_n, out i6_n) != ~0x00)
		{
			word32 i2_n;
			word32 i6_n;
			pwait((char *) i6_n - 0x001C, out i2_n, out i6_n);
		}
		else
		{
			char * l2_n = globals->ptr2B760;
			*l2Out = l2_n;
			fprintf(&globals->t2B640, "%s: ", l0_n->ptr0150);
			fprintf(&globals->t2B640, i6_n->ptrFFFFFFEC, i6_n->ptrFFFFFFE8);
			fprintf(&globals->t2B640, ": %s\n", xstrerror(l2_n));
			word32 l1_n;
			*l1Out = 177728;
			word32 l0_n;
			*l0Out = 0x00017270;
			word32 i2_n;
			word32 i6_n;
			Eq_n i0_n = pwait(globals->str17270, out i2_n, out i6_n);
			*i0Out = i0_n;
			word32 sp_n;
			*spOut = i6_n;
			return i0_n;
		}
	}
	else
	{
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice("%s: compiling `%s'\n", dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
	}
}

// 00013034: Register (ptr32 char) process_aux_info_file(Register Eq_n o0, Register word32 o2, Register out ptr32 l1Out, Register out ptr32 l2Out)
char * process_aux_info_file(Eq_n o0, word32 o2, ptr32 & l1Out, ptr32 & l2Out)
{
	*l1Out = l1;
	word32 sp_n = fp + ~0xFB - (strlen(o0) + 0x0A & ~0x07);
	strcpy(sp_n + 0x60, o0);
	strcat(sp_n + 0x60, ".X");
	Eq_n i0_n = o0;
	word32 i2_n = o2;
	struct Eq_n * i6_n = fp;
	Eq_n l4_n = sp_n + 0x60;
	word32 l2_n;
	*l2Out = 0x00;
	while (true)
	{
		Eq_n Z_n;
		char * o0_n;
		if (access(l4_n, 0x04) == ~0x00)
		{
			if (globals->ptr2B760 != (char *) 0x02)
			{
				char * l0_n;
				word32 l1_n;
				word32 l2_n;
				char * l3_n;
				word32 l4_n;
				word32 i0_n;
				word32 i1_n;
				shortpath(0x00, l4_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
				xstrerror(l3_n);
				o0_n = l0_n;
				goto l000131F0;
			}
			if (i2_n != 0x00)
			{
				word32 i1_n;
				i0_n = notice("%s: warning: missing SYSCALLS file `%s'\n", dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
				word32 l2_n;
				*l2Out = 0x01;
				return l0;
			}
			word32 l2_n;
			*l2Out = 0x01;
			Z_n = cond(0x01);
		}
		else
			Z_n = cond(l2_n);
		struct stat * l1_n;
		Eq_n o1_n;
		if (!Z_n)
		{
			word32 sp_n;
			word32 l1_n;
			word32 l2_n;
			if (gen_aux_info_file(i0_n, out sp_n, out l0, out l1_n, out l2_n, out l4_n, out i0_n, out i2_n, out i6_n) == 0x00)
			{
				++globals->dw27F20;
				return l0;
			}
			if (access(l4_n, 0x04) == ~0x00)
			{
				o1_n = l4_n;
				goto l000131D0;
			}
			*l1Out = (char *) i6_n - 0x0098;
		}
		else
			*l1Out = (char *) i6_n - 0x0098;
		if (stat(l4_n, l1_n) == ~0x00)
			break;
		l0 = i6_n->ptrFFFFFF98;
		if (l0 == null)
			return l0;
		if (i2_n != 0x00)
		{
l00013218:
			Eq_n o0_n = open(l4_n, 0x00);
			if (o0_n != ~0x00)
			{
				word32 i0_n;
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				Eq_n o0_n = xmalloc(l0 + 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
				Mem228[o0_n + l0:byte] = 0x00;
				word32 l1_n;
				word32 l2_n;
				word32 o0_n = safe_read(o0_n, o0_n, l0, out l0, out l1_n, out l2_n);
				if (o0_n - l0 != 0x00 || close(o0_n) != 0x00)
				{
					word32 l1_n;
					char * l2_n;
					word32 l3_n;
					word32 l4_n;
					word32 i0_n;
					word32 i1_n;
					word32 l1_n;
					*l1Out = shortpath(0x00, l4_n, out l0, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
					xstrerror(l2_n);
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					notice(l0, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
					free(o0_n);
					close(o0_n);
				}
				return l0;
			}
			else
			{
				char * l0_n;
				word32 l1_n;
				char * l2_n;
				word32 l3_n;
				word32 l4_n;
				word32 i0_n;
				word32 i1_n;
				shortpath(0x00, l4_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
				xstrerror(l2_n);
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
			}
		}
		int32 l7_n = i6_n->dwFFFFFFA8;
		if (stat(i0_n, l1_n) == ~0x00)
		{
			o1_n = i0_n;
			goto l000131D0;
		}
		int32 o0_n = i6_n->dwFFFFFFA8;
		if (o0_n - l7_n <= 0x00)
			goto l00013218;
		*l2Out = 0x01;
	}
	o1_n = l4_n;
l000131D0:
	char * l0_n;
	word32 l1_n;
	char * l2_n;
	word32 l3_n;
	word32 l4_n;
	word32 i0_n;
	word32 i1_n;
	shortpath(0x00, o1_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
	xstrerror(l2_n);
	o0_n = l0_n;
l000131F0:
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	notice(o0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
}

// 000135C0: void reverse_def_dec_list(Register (ptr32 Eq_n) o0)
void reverse_def_dec_list(Eq_n * o0)
{
	struct Eq_n * o1_n = o0->ptr0008;
	struct Eq_n * g3_n = o1_n->ptr0004;
	if (g3_n != null)
	{
		struct Eq_n * o0_n = g3_n;
		struct Eq_n * g3_n = g3_n->ptr0000;
		if (g3_n != null)
		{
			g3_n->ptr0000 = null;
			struct Eq_n * g2_n = g3_n->ptr0000;
			while (true)
			{
				g3_n->ptr0000 = o0_n;
				o0_n = g3_n;
				g3_n = g2_n;
				if (g2_n == null)
					break;
				g2_n = g2_n->ptr0000;
			}
			o1_n->ptr0004 = g3_n;
		}
	}
}

// 0001360C: Register Eq_n identify_lineno(Register Eq_n o0)
Eq_n identify_lineno(Eq_n o0)
{
	Eq_n o0_n;
	Eq_n g3_n = globals->t281C0;
	if (g3_n - o0 < 0x00)
	{
		&o0_n.u0->b0000 = 0x01;
		int32 g2_n = (int32) *g3_n;
		while (true)
		{
			if (g2_n == 0x0A)
				o0_n = &o0_n.u0->b0001;
			g3_n = (word32) g3_n + 0x01;
			if (g3_n - o0 > 0x00)
				break;
			g2_n = (int32) *g3_n;
		}
	}
	else
		&o0_n.u0->b0000 = (struct Eq_n *) 0x01;
	return o0_n;
}

// 0001364C: void declare_source_confusing(Register Eq_n o0)
void declare_source_confusing(Eq_n o0)
{
	if (globals->dw27F2C == 0x00)
	{
		if (o0 == 0x00)
		{
			char * l0_n;
			word32 l1_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			word32 i1_n;
			shortpath(0x00, globals->t28180, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
		}
		else
		{
			char * l0_n;
			word32 l1_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			Eq_n i0_n;
			word32 i1_n;
			shortpath(0x00, globals->t28180, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
			identify_lineno(i0_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
		}
	}
	longjmp(0x0002B240, 0x01);
}

// 000136E0: Register Eq_n check_source(Register Eq_n o0, Register Eq_n o1, Register out ptr32 i1Out, Register out (ptr32 Eq_n) i2Out, Register out (ptr32 Eq_n) i6Out)
Eq_n check_source(Eq_n o0, Eq_n o1, ptr32 & i1Out, Eq_n * & i2Out, Eq_n * & i6Out)
{
	word32 i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	if (o0 != 0x00)
		return o0;
	declare_source_confusing(o1);
}

// 00013700: void seek_to_line(Register Eq_n o0)
void seek_to_line(Eq_n o0)
{
	Eq_n i0_n = o0;
	int32 g0_n = o0 - globals->dw28230;
	if (g0_n >= 0x00)
	{
		if (g0_n > 0x00)
		{
			while (true)
			{
				int32 o1_n;
				int8 * o0_n = globals->ptr28220;
				if ((int32) *o0_n != 0x0A)
				{
					int8 * o2_n = globals->ptr28220;
					while (true)
					{
						int8 * o2_n = o2_n + 0x01;
						up32 g0_n = o2_n - globals->dw281D0;
						globals->ptr28220 = o2_n;
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						i0_n = check_source(g0_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
						if ((int32) *globals->ptr28220 == 0x0A)
							break;
						o2_n = globals->ptr28220;
					}
					o0_n = globals->ptr28220;
					o1_n = globals->dw28230;
				}
				else
					o1_n = globals->dw28230;
				globals->ptr28220 = o0_n + 0x01;
				int32 o1_n = o1_n + 0x01;
				if (i0_n - o1_n <= 0x00)
					break;
				globals->dw28230 = o1_n;
			}
			globals->dw28230 = o1_n;
		}
	}
	else
		abort();
}

// 000137AC: Register Eq_n forward_to_next_token_char(Register Eq_n o0)
Eq_n forward_to_next_token_char(Eq_n o0)
{
	Eq_n i0_n = (word32) o0 + 0x01;
	if (((word32) ((word32) *((word32) o0 + 0x01) + 177169) & 0x08) != 0x00)
	{
		up32 o0_n = globals->dw281D0;
		while (true)
		{
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			i0_n = check_source((word32) i0_n + 0x01 - o0_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
			if (((word32) ((word32) *i0_n + 177169) & 0x08) == 0x00)
				break;
			o0_n = globals->dw281D0;
		}
	}
	return i0_n;
}

// 00013808: Register up32 output_bytes(Register Eq_n o0, Register Eq_n o1, Register out ptr32 l1Out, Register out ptr32 l2Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
up32 output_bytes(Eq_n o0, Eq_n o1, ptr32 & l1Out, ptr32 & l2Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	up32 l0_n = globals->dw28200;
	void * i0_n;
	*i0Out = o0;
	Eq_n i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	word32 l2_n;
	*l2Out = 0x00028000;
	if (globals->dw28210 + ((word32) o1 + 0x01) - l0_n >= 0x00)
	{
		Eq_n o0_n = globals->t281F0;
		uint32 l0_n = l0_n - o0_n;
		word32 i2_n;
		word32 i6_n;
		Eq_n o0_n = xrealloc(o0_n, l0_n << 0x01, out i0_n, out i1_n, out i2_n, out i6_n);
		up32 o1_n = globals->dw28210;
		l0_n = (word32) o0_n + (l0_n << 0x01);
		Eq_n o2_n = globals->t281F0;
		globals->dw28200 = l0_n;
		globals->dw28210 = (word32) o0_n + (o1_n - o2_n);
		globals->t281F0 = o0_n;
	}
	memcpy(globals->dw28210 + 0x01, i0_n, i1_n);
	globals->dw28210 = (word32) i1_n + globals->dw28210;
	word32 l1_n;
	*l1Out = 0x00028000;
	return l0_n;
}

// 0001388C: Register word32 output_string(Register Eq_n o0, Register out ptr32 l2Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
word32 output_string(Eq_n o0, ptr32 & l2Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	word32 l1_n;
	word32 l2_n;
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	output_bytes(o0, strlen(o0), out l1_n, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
	return l1_n;
}

// 000138AC: Register word32 output_up_to(Register (ptr32 Eq_n) o0, Register out ptr32 l2Out, Register out ptr32 i0Out, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
word32 output_up_to(Eq_n * o0, ptr32 & l2Out, ptr32 & i0Out, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	*l2Out = l2;
	uint32 o2_n = globals->dw281E0;
	word32 i0_n;
	*i0Out = o0;
	word32 i1_n;
	*i1Out = o1;
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	word32 o0_n = globals->dw281A0 + (o2_n - globals->t281C0);
	Eq_n o1_n = o0 - o2_n;
	if (o1_n != 0x00)
	{
		word32 l2_n;
		word32 i0_n;
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		struct Eq_n * l0_n = output_bytes(o0_n + 0x01, o1_n, out l1, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
		l0_n->dw01E0 = i0_n;
	}
	return l1;
}

// 000138F0: Register Eq_n other_variable_style_function(Register Eq_n o0, Register out ptr32 i1Out, Register out ptr32 i6Out)
Eq_n other_variable_style_function(Eq_n o0, ptr32 & i1Out, ptr32 & i6Out)
{
	word32 i1_n;
	*i1Out = o1;
	word32 i6_n;
	*i6Out = fp;
	return substr(o0, &globals->b17468) > 0x00;
}

// 00013914: void edit_fn_declaration(Register (ptr32 Eq_n) o0, Stack word32 dwArg44, Stack word32 dwArg48)
void edit_fn_declaration(Eq_n * o0, word32 dwArg44, word32 dwArg48)
{
	strlen(o0->ptr0010->t0004);
	save_pointers();
	if (setjmp(0x0002B240) != 0x00)
	{
		restore_pointers();
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice("%s: declaration of function `%s' not converted\n", dwLoc38, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, out i1_n, out i2_n, out i6_n);
	}
}

// 00013B68: Register Eq_n edit_formals_lists(Register Eq_n o0, Register out ptr32 spOut, Register out ptr32 l1Out, Register out ptr32 l2Out, Register out ptr32 i1Out, Register out ptr32 i2Out, Register out ptr32 i6Out)
Eq_n edit_formals_lists(Eq_n o0, ptr32 & spOut, ptr32 & l1Out, ptr32 & l2Out, ptr32 & i1Out, ptr32 & i2Out, ptr32 & i6Out)
{
	int8 * l1_n = (word32) o0 - 0x01;
	word32 l0_n = 0x01;
	struct Eq_n * l2_n = &globals->t28000;
	int32 o0_n = (int32) *((word32) o0 - 0x01);
l00013B7C:
	uint32 o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = globals->dw281E0;
			l1_n += -0x01;
			goto l00013BAC;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n = globals->dw281E0;
	l1_n += -0x01;
l00013BAC:
	word32 i1_n;
	word32 i6_n;
	struct Eq_n * i2_n;
	check_source(o0_n - l1_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
	if (l0_n == 0x00)
	{
		word32 i6_n;
		struct Eq_n * l1_n;
		Eq_n Z_n;
		Eq_n i0_n;
		if (i1_n != ~0x00)
		{
			struct Eq_n * l1_n = l1_n + 0x01;
			int32 o0_n;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(globals->dw281E0 - &l1_n->bFFFFFFFF < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n = &l1_n->bFFFFFFFF;
			if (((word32) ((word32) l1_n->bFFFFFFFF + 177169) & 0x08) != 0x00)
			{
				uint32 o0_n = globals->dw281E0;
				while (true)
				{
					l0_n = (word32) l0_n - 0x01;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					check_source(o0_n - l0_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
					if (((word32) ((word32) *l0_n + 177169) & 0x08) == 0x00)
						break;
					o0_n = globals->dw281E0;
				}
				o0_n = (int32) *l0_n;
			}
			else
				o0_n = (int32) l1_n->bFFFFFFFF;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(0x01 - ((o0_n ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			Eq_n l0_n = (word32) l0_n - 0x01;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(globals->dw281E0 - l0_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			check_source(0x01 - (((int32) (*l0_n) ^ 0x29) > 0x00), l0_n, out i1_n, out i2_n, out i6_n);
			word32 sp_n;
			word32 i1_n;
			if (edit_formals_lists(l0_n, out sp_n, out l1_n, out l2_n, out i1_n, out i2_n, out i6_n) != 0x00)
			{
				&i0_n.u0->b0000 = 0x01;
				goto l00013DFC;
			}
			Z_n = cond(i1_n);
		}
		else
		{
			l1_n = (struct Eq_n *) (l1_n + 0x01);
			Z_n = cond(i1_n + ~0x00);
		}
		if (!Z_n)
		{
			Eq_n l5_n;
			struct Eq_n * o1_n = i2_n->ptr0010;
			int8 * l0_n = &l1_n->bFFFFFFFF;
			if (((word32) ((word32) l1_n->bFFFFFFFF + 177169) & 0x08) != 0x00)
			{
				l5_n = o1_n->t0004;
				uint32 o0_n = l2_n->dw01E0;
				while (true)
				{
					l0_n += -0x01;
					word32 i1_n;
					word32 i6_n;
					check_source(o0_n - l0_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
					if (((word32) ((word32) *l0_n + 177169) & 0x08) == 0x00)
						break;
					o0_n = l2_n->dw01E0;
				}
			}
			else
				l5_n = o1_n->t0004;
			int8 * l3_n = l0_n;
			Eq_n l0_n = l0_n + 0x01;
			while (is_id_char((int32) *l3_n) != 0x00)
			{
				uint32 o0_n = l2_n->dw01E0;
				word32 i1_n;
				word32 i6_n;
				check_source(o0_n - l3_n < 0x00, 0x00, out i1_n, out i2_n, out i6_n);
				l3_n += -0x01;
			}
			Eq_n l3_n = l3_n + 0x01;
			Eq_n l4_n = l0_n - l3_n;
			if (l4_n == 0x00)
			{
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				check_source(0x00, l3_n, out i1_n, out i2_n, out i6_n);
			}
			struct Eq_n ** o0_n;
			if (l4_n - strlen(l5_n) != 0x00)
			{
				o0_n = i2_n->ptr0004;
				goto l00013D80;
			}
			if (strncmp(l3_n, l5_n, l4_n) != 0x00)
			{
				o0_n = i2_n->ptr0004;
l00013D80:
				word32 l0_n;
				word32 l1_n;
				word32 l2_n;
				Eq_n l3_n;
				Eq_n l4_n;
				word32 i0_n;
				word32 i1_n;
				word32 l2_n;
				*l2Out = shortpath(0x00, *((char *) *o0_n + 0x04), out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
				word32 l1_n;
				*l1Out = identify_lineno(l3_n);
				char * l0_n;
				word32 i0_n;
				word32 i6_n;
				dupnstr(l3_n, l4_n, out l0_n, out i0_n, out i6_n);
				word32 i1_n;
				word32 i2_n;
				notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
				&i0_n.u0->b0000 = 0x01;
				goto l00013DFC;
			}
		}
		uint32 o0_n;
		word32 l2_n;
		word32 i0_n;
		word32 i1_n;
		struct Eq_n * i2_n;
		word32 l1_n;
		*l1Out = output_up_to(l1_n, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
		if (i1_n == 0x00)
		{
			word32 l2_n;
			word32 i0_n;
			word32 i1_n;
			word32 i2_n;
			word32 l1_n;
			*l1Out = output_string(i2_n->t0024, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
			o0_n = i0_n + ~0x00;
		}
		else
			o0_n = i0_n + ~0x00;
		globals->dw281E0 = o0_n;
		&i0_n.u0->b0000 = 0x00;
l00013DFC:
		word32 sp_n;
		*spOut = i6_n;
		return i0_n;
	}
	o0_n = (int32) *l1_n;
	goto l00013B7C;
}

// 00013E04: Register Eq_n find_rightmost_formals_list(Register Eq_n o0, Register out ptr32 i6Out)
Eq_n find_rightmost_formals_list(Eq_n o0, ptr32 & i6Out)
{
	int8 * i0_n = (word32) o0 - 0x01;
	int32 o0_n = (int32) *o0;
	while (o0_n != 0x0A)
	{
		++i0_n;
		o0_n = (int32) *i0_n;
	}
	Eq_n i0_n = i0_n;
	if ((int32) *i0_n != 0x29)
	{
		struct Eq_n * o1_n = (word32) *i0_n;
		while (true)
		{
			int32 o0_n;
			if (((word32) o1_n->b2B411 & 0x08) != 0x00)
			{
				uint32 o0_n = globals->dw281E0;
				while (true)
				{
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					i0_n = check_source(o0_n - (i0_n + ~0x00) <u 0x00, 0x00, out i1_n, out i2_n, out i6_n);
					if (((word32) ((word32) *i0_n + 177169) & 0x08) == 0x00)
						break;
					o0_n = globals->dw281E0;
				}
				o0_n = (int32) *i0_n;
			}
			else
			{
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				i0_n = check_source(Mem0[0x000281E0:word32] - (i0_n + ~0x00) <u 0x00, 0x00, out i1_n, out i2_n, out i6_n);
				o0_n = (int32) *i0_n;
			}
			if (o0_n == 0x29)
				break;
			o1_n = (word32) *i0_n;
		}
	}
	Eq_n o0_n = forward_to_next_token_char(i0_n);
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	return check_source(0x01 - (((int32) (*o0_n) ^ 0x7B) > 0x00), o0_n, out i1_n, out i2_n, out i6_n);
}

// 00013EDC: void edit_fn_definition(Register word32 o0, Register Eq_n o1, Stack word32 dwArg44, Stack word32 dwArg48)
void edit_fn_definition(word32 o0, Eq_n o1, word32 dwArg44, word32 dwArg48)
{
	save_pointers();
	if (setjmp(0x0002B240) != 0x00)
	{
		restore_pointers();
		struct Eq_n * i1_n;
		word32 i2_n;
		word32 i6_n;
		notice("%s: definition of function `%s' not converted\n", dwLoc34, dwLoc30, dwLoc2C, dwLoc28, dwLoc24, out i1_n, out i2_n, out i6_n);
		word32 l2_n;
		word32 i0_n;
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
	}
	else
	{
		struct Eq_n * i6_n;
		find_rightmost_formals_list(o1, out i6_n);
		struct Eq_n * i1_n;
		struct Eq_n * i6_n;
		if (other_variable_style_function(i6_n->ptr0044->t000C, out i1_n, out i6_n) != 0x00)
		{
			if (globals->dw27F2C != 0x00)
			{
				word32 l2_n;
				word32 i0_n;
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				output_up_to(i1_n, out l2_n, out i0_n, out i1_n, out i2_n, out i6_n);
			}
			else
			{
				struct Eq_n * o1_n = i6_n->ptr0044;
				char * l0_n;
				word32 l1_n;
				word32 l2_n;
				word32 l3_n;
				word32 l4_n;
				word32 i0_n;
				Eq_n i1_n;
				shortpath(0x00, *((char *) *o1_n->ptr0004 + 0x04), out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
				identify_lineno(i1_n);
				word32 i1_n;
				word32 i2_n;
				word32 i6_n;
				notice(l0_n, o1, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
			}
		}
	}
}

// 000140B4: void do_cleaning(Register (ptr32 byte) o0, Register up32 o1)
void do_cleaning(byte * o0, up32 o1)
{
	byte * i0_n = o0;
	if (o0 - o1 >= 0x00)
		return;
	word32 o1_n = (word32) *o0;
	while (o1_n + ~0x07 << 0x18 >> 0x18 >= 0x54)
	{
		++i0_n;
		if (i0_n - o1 >= 0x00)
			return;
		o1_n = (word32) *i0_n;
	}
}

// 00014518: Register Eq_n careful_find_l_paren(Register Eq_n o0, Register out ptr32 spOut, Register out (ptr32 Eq_n) i6Out)
Eq_n careful_find_l_paren(Eq_n o0, ptr32 & spOut, Eq_n * & i6Out)
{
	Eq_n i0_n = (word32) o0 - 0x01;
	word32 l0_n = 0x01;
	int32 o0_n = (int32) *((word32) o0 - 0x01);
l0001452C:
	Eq_n o0_n;
	if (o0_n != 0x28)
	{
		int32 g0_n = o0_n - 0x29;
		if (g0_n != 0x00)
		{
			o0_n = globals->t281C0;
l00014550:
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			i0_n = check_source(0x01 - (((word32) i0_n - 0x01) - o0_n < 0x00), 0x00, out i1_n, out i2_n, out i6_n);
			if (l0_n == 0x00)
			{
				word32 sp_n;
				*spOut = i6_n;
				return (word32) i0_n + 0x01;
			}
			o0_n = (int32) *i0_n;
			goto l0001452C;
		}
		++l0_n;
	}
	else
		l0_n += ~0x00;
	o0_n = globals->t281C0;
	goto l00014550;
}

// 00014578: void scan_for_missed_items(Stack word32 dwArg44)
void scan_for_missed_items(word32 dwArg44)
{
	Eq_n o1_n = globals->t281C0;
	up32 o0_n = globals->dw281D0;
	globals->t28130 = (word32) o1_n - 0x01;
	struct Eq_n * i6_n = fp;
	if (o1_n - (o0_n + ~0x02) >= 0x00)
	{
		globals->t28120 = o1_n;
		return;
	}
	globals->t28120 = o1_n;
l000145B4:
	Eq_n o3_n = globals->t28120;
	if ((int32) *o3_n == 0x29)
	{
		Eq_n l0_n;
		globals->t28140 = o3_n;
		if (((word32) ((word32) *((word32) o3_n + 0x01) + 177169) & 0x08) != 0x00)
		{
			l0_n = (word32) o3_n + 0x01;
			Eq_n o0_n = i6_n->tFFFFFFEC;
			while (true)
			{
				l0_n = (word32) l0_n + 0x01;
				word32 i1_n;
				word32 i2_n;
				check_source(l0_n - o0_n < 0x00, i6_n->tFFFFFFEC, out i1_n, out i2_n, out i6_n);
				if (((word32) ((word32) *l0_n + 177169) & 0x08) == 0x00)
					break;
				o0_n = i6_n->tFFFFFFEC;
			}
		}
		else
			l0_n = (word32) o3_n + 0x01;
		globals->t28120 = (word32) l0_n - 0x01;
		struct Eq_n * o2_n = (word32) *l0_n;
		if (((word32) o2_n->b2B411 & 0x03) != 0x00 || o2_n == (struct Eq_n *) 0x7B)
		{
			i6_n->dwFFFFFFE8 = identify_lineno(l0_n);
			if (setjmp(0x0002B240) != 0x00)
				goto l00014854;
			do
			{
				Eq_n o0_n;
				word32 sp_n;
				struct Eq_n * o0_n = careful_find_l_paren(globals->t28140, out sp_n, out i6_n);
				globals->t28140 = &o0_n->bFFFFFFFF;
				if (((word32) ((word32) o0_n->bFFFFFFFF + 177169) & 0x08) != 0x00)
				{
					Eq_n i0_n = 0x00028000;
					Eq_n o2_n = globals->t28140;
					while (true)
					{
						Eq_n o1_n = *((word32) i0_n + 0x0130);
						Eq_n o2_n = (word32) o2_n - 0x01;
						globals->t28140 = o2_n;
						word32 i1_n;
						word32 i2_n;
						i0_n = check_source(0x01 - (o2_n - o1_n < 0x00), o1_n, out i1_n, out i2_n, out i6_n);
						if (((word32) ((word32) *globals->t28140 + 177169) & 0x08) == 0x00)
							break;
						o2_n = globals->t28140;
					}
					o0_n = globals->t28140;
				}
				else
					o0_n = globals->t28140;
			} while ((int32) *o0_n == 0x29);
			if (is_id_char((int32) *globals->t28140) != 0x00)
			{
				Eq_n o0_n = globals->t28140;
				if (is_id_char((int32) *o0_n) != 0x00)
				{
					Eq_n o1_n = globals->t28130;
					word32 i1_n;
					word32 i2_n;
					word32 i6_n;
					check_source(0x01 - (((word32) o0_n - 0x01) - o1_n < 0x00), o1_n, out i1_n, out i2_n, out i6_n);
				}
				word32 l0_n = o0_n + 0x01 - (o0_n + 0x01);
				if (l0_n != 0x00)
				{
					Mem207[164144:word32] = o0_n + 0x01;
					struct Eq_n * sp_n = sp_n - (l0_n + 0x6B & ~0x07);
					strncpy(sp_n->a0060, o0_n + 0x01, l0_n);
					Eq_n o0_n = globals->t1753C;
					sp_n->a0060[l0_n] = 0x00;
					if (o0_n == 0x00)
					{
l000147BC:
						struct Eq_n * o1_n;
						struct Eq_n * o1_n = i6_n->ptr0044->ptr0004;
						if (o1_n != null)
						{
							word32 o0_n = o1_n->dw0014;
							while (true)
							{
								if (o0_n != 0x00)
								{
									word32 o2_n = i6_n->dwFFFFFFE8;
									if (o1_n->dw0008 - o2_n == 0x00)
										goto l00014854;
								}
								o1_n = o1_n->ptr0000;
								if (o1_n == null)
									break;
								o0_n = o1_n->dw0014;
							}
							o1_n = i6_n->ptr0044;
						}
						else
							o1_n = i6_n->ptr0044;
						char * l0_n;
						word32 l1_n;
						word32 l2_n;
						word32 l3_n;
						word32 l4_n;
						Eq_n i0_n;
						word32 i1_n;
						shortpath(0x00, o1_n->ptr0000->t0004, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
						identify_lineno(i0_n);
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
						word32 i1_n;
						word32 i2_n;
						word32 i6_n;
						notice("%s: function definition not converted\n", dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
					}
					word32 * l0_n = &globals->t1753C;
					Eq_n o1_n = globals->t1753C;
					while (strcmp(sp_n->a0060, o1_n) != 0x00)
					{
						++l0_n;
						if (*l0_n == 0x00)
							goto l000147BC;
						o1_n = *l0_n;
					}
				}
				else
					Mem314[164144:word32] = o0_n + 0x01;
			}
			goto l00014854;
		}
	}
l00014854:
	Eq_n o0_n = globals->t28120;
	if ((word32) o0_n + 0x01 - i6_n->tFFFFFFEC >= 0x00)
	{
		globals->t28120 = (word32) o0_n + 0x01;
		return;
	}
	globals->t28120 = (word32) o0_n + 0x01;
	goto l000145B4;
}

// 00014878: void edit_file(Register (ptr32 Eq_n) o0)
void edit_file(Eq_n * o0)
{
	struct Eq_n * i0_n = o0->ptr0008;
	if (needs_to_be_converted(i0_n) == 0x00)
		return;
	Eq_n o1_n = i0_n->ptr0000->t0004;
	globals->t28180 = o1_n;
	if (directory_specified_p(o1_n) == 0x00 || file_excluded_p(globals->t28180) != 0x00)
	{
		if (globals->dw27F2C == 0x00 && in_system_include_dir(globals->t28180) == 0x00)
		{
			char * l0_n;
			word32 l1_n;
			word32 l2_n;
			word32 l3_n;
			word32 l4_n;
			word32 i0_n;
			word32 i1_n;
			shortpath(0x00, globals->t28180, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			notice(l0_n, dwArg48, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
		}
	}
}

// 00014E24: void do_processing()
void do_processing()
{
	Eq_n o0_n = globals->t28160;
	if (o0_n - ((word32) o0_n + (globals->dw27F4C << 0x02)) < 0x00)
	{
		Eq_n o0_n = *o0_n;
		while (true)
		{
			up32 l1_n;
			word32 l2_n;
			union Eq_n * l0_n = process_aux_info_file(o0_n, 0x00, out l1_n, out l2_n);
			if (l0_n - l1_n >= 0x00)
				break;
			o0_n = *l0_n;
		}
	}
	visit_each_hash_node(visit_each_hash_node(&globals->t28240));
}

// 00014EA4: Register ui32 main(Register Eq_n o1, Stack word32 dwArg44, Stack word32 dwArg48)
ui32 main(Eq_n o1, word32 dwArg44, word32 dwArg48)
{
	Eq_n o0_n = strrchr(*o1, 0x2F);
	Eq_n o2_n = (word32) o0_n + 0x01;
	if (o0_n == 0x00)
	{
		globals->t28150 = o0_n;
		o2_n = *o1;
	}
	else
		globals->t28150 = o0_n;
	globals->t28150 = o2_n;
	setlocale(0x05, "");
	Eq_n o0_n = getpwd();
	if (o0_n != 0x00)
	{
		globals->t2B270 = o0_n;
		struct Eq_n * i6_n;
		globals->ptr2B764 = string_list_cons(out i6_n);
		word32 o0_n = i6_n->dw0044;
		struct Eq_n * l6_n;
		struct Eq_n * l7_n;
		struct Eq_n * i6_n;
		struct Eq_n * l0_n = getopt_long(o0_n, i6_n->ptr0048, &globals->b17838, 163672, (char *) i6_n - 0x0014, out l6_n, out l7_n, out i6_n);
		if (o0_n != ~0x00)
		{
			uint32 o0_n;
			if (o0_n == 0x00)
				o0_n = l0_n->a000C[i6_n->dwFFFFFFEC].dw0000 + ~0x4D;
			else
				o0_n = o0_n + ~0x4D;
			if (o0_n < 0x2A)
				return o0_n << 0x02;
			usage();
		}
		else
		{
			word32 i0_n;
			struct Eq_n * i6_n;
			munge_compile_params(i6_n->tFFFFFFE8, out i0_n, out i6_n);
			ui32 o1_n = i6_n->dw0044 - l7_n->dw0068;
			l6_n->dw034C = o1_n;
			word32 i0_n;
			word32 i1_n;
			word32 i2_n;
			struct Eq_n * i6_n;
			globals->t28160 = xmalloc(o1_n + 0x01 << 0x02, out i0_n, out i1_n, out i2_n, out i6_n);
			int32 o1_n = l7_n->dw0068;
			l6_n->dw034C = 0x00;
			if (o1_n - i6_n->dw0044 < 0x00)
			{
				struct Eq_n * l4_n = l6_n;
				struct Eq_n * l2_n = l7_n;
				while (true)
				{
					word32 sp_n;
					word32 l0_n;
					word32 i1_n;
					Eq_n o0_n = abspath(0x00, i6_n->ptr0048[l7_n->dw0068], out sp_n, out l0_n, out i1_n, out i6_n);
					word32 o1_n = strlen(o0_n) + o0_n;
					if ((int32) (&o1_n->tFFFFFFFF.bFFFFFFFE)[0x02] == 99 && (int32) o1_n->bFFFFFFFE == 0x2E)
					{
						ui32 o0_n = l4_n->dw034C;
						*((word32) globals->t28160 + o0_n * 0x04) = o0_n;
						l4_n->dw034C = o0_n + 0x01;
					}
					else
					{
						word32 l0_n;
						word32 l1_n;
						struct Eq_n * l3_n;
						word32 i0_n;
						word32 i1_n;
						shortpath(0x00, o0_n, out l0_n, out l1_n, out l2_n, out l3_n, out l4_n, out i0_n, out i1_n);
						word32 i1_n;
						word32 i2_n;
						notice("%s: input file names must have .c suffixes: %s\n", o1, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
						++l3_n->dw0320;
					}
					int32 o0_n = l2_n->dw0068;
					if (o0_n + 0x01 - i6_n->dw0044 >= 0x00)
						break;
					l2_n->dw0068 = o0_n + 0x01;
				}
				l2_n->dw0068 = o0_n + 0x01;
			}
			if (globals->dw27F20 == 0x00)
			{
				if (globals->dw27F28 == 0x00)
				{
					int32 o1_n;
					do_processing();
					if (globals->dw27F20 != 0x00)
						o1_n = 33;
					else
						o1_n = 0x00;
					exit(o1_n);
				}
				else
					fprintf(&globals->t2B640, "%s: %s\n", globals->t28150, globals->ptr28028);
			}
			else
				usage();
		}
	}
	else
	{
		globals->t2B270 = o0_n;
		xstrerror(globals->ptr2B760);
		word32 i1_n;
		word32 i2_n;
		word32 i6_n;
		notice("%s: cannot get working directory: %s\n", o1, dwArg4C, dwArg50, dwArg54, dwArg58, out i1_n, out i2_n, out i6_n);
		exit(33);
	}
}

// 000152B8: Register Eq_n getpwd()
Eq_n getpwd()
{
	Eq_n i0_n = globals->t2B2A0;
	if (i0_n != 0x00)
		return i0_n;
	char * o2_n = globals->ptr2B2B0;
	if (o2_n != null)
	{
		globals->ptr2B760 = o2_n;
		return i0_n;
	}
	else
	{
		globals->ptr2B760 = o2_n;
		Eq_n l1_n;
		Eq_n o0_n = getenv("PWD");
		i0_n = o0_n;
		if (o0_n != 0x00)
		{
			&l1_n.u0->b0000 = 100;
			if ((int32) *o0_n == 0x2F)
			{
				if (stat(o0_n, fp + ~0x011F) == 0x00)
				{
					if (stat(96400, fp + ~0x97) == 0x00)
					{
						if (dwLoc88 - dwLoc0110 == 0x00)
						{
							if (dwLoc98 - dwLoc0120 == 0x00)
							{
								globals->t2B2A0 = o0_n;
								return i0_n;
							}
							&l1_n.u0->b0000 = 100;
						}
						else
							&l1_n.u0->b0000 = 100;
					}
					else
						&l1_n.u0->b0000 = 100;
				}
				else
					&l1_n.u0->b0000 = 100;
			}
		}
		else
			&l1_n.u0->b0000 = (struct Eq_n *) 100;
		while (true)
		{
			word32 i0_n;
			word32 i1_n;
			word32 i2_n;
			word32 i6_n;
			Eq_n o0_n = xmalloc(l1_n, out i0_n, out i1_n, out i2_n, out i6_n);
			i0_n = o0_n;
			if (getcwd(o0_n, l1_n) != null)
				break;
			char * l0_n = globals->ptr2B760;
			free(o0_n);
			if (l0_n != (char *) 0x22)
			{
				&i0_n.u0->b0000 = 0x00;
				globals->ptr2B760 = l0_n;
				globals->ptr2B2B0 = l0_n;
				break;
			}
			l1_n <<= 0x01;
		}
		globals->t2B2A0 = i0_n;
		return i0_n;
	}
}

// 000153C4: void _obstack_begin(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4)
void _obstack_begin(Eq_n * o0, word32 o1, word32 o2, code * o3, word32 o4)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	struct Eq_n * i0_n;
	struct Eq_n * i1_n;
	int32 o1_n = o0->dw0028 & ~0x80000000;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	if (o1_n < 0x00)
	{
		o0->dw0028 = o1_n;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		o3();
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o1_n;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		o3();
		i1_n = o0_n;
	}
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 0x01;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n / 0x08;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		word32 sp_n;
		word32 i0_n;
		word32 o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		fn00000FE8();
	}
}

// 00015488: void _obstack_begin_n(Register (ptr32 Eq_n) o0, Register word32 o1, Register word32 o2, Register (ptr32 code) o3, Register word32 o4, Register word32 o5)
void _obstack_begin_n(Eq_n * o0, word32 o1, word32 o2, code * o3, word32 o4, word32 o5)
{
	word32 i1_n = o1;
	word32 i2_n = o2;
	if (o2 == 0x00)
		i2_n = 0x08;
	if (o1 == 0x00)
		i1_n = 0x0FE8;
	struct Eq_n * i0_n;
	struct Eq_n * i1_n;
	ui32 o0_n = o0->dw0028;
	o0->dw0020 = o4;
	word32 o2_n = i2_n + ~0x00;
	o0->dw0018 = o2_n;
	o0->ptr001C = o3;
	o0->dw0000 = i1_n;
	o0->dw0024 = o5;
	if ((o0_n | 0x80000000) < 0x00)
	{
		o0->dw0028 = o0_n | 0x80000000;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		o3();
		i1_n = o0_n;
	}
	else
	{
		o0->dw0028 = o0_n | 0x80000000;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		o3();
		i1_n = o0_n;
	}
	if (i1_n != null)
	{
		i0_n->ptr0004 = i1_n;
		word32 o0_n = i0_n->dw0000;
		word32 o1_n = &i1_n->dw0004 + 0x01;
		i0_n->dw000C = o1_n;
		i0_n->dw0008 = o1_n;
		word32 o0_n = i1_n + o0_n / 0x08;
		i1_n->dw0000 = o0_n;
		i0_n->dw0010 = o0_n;
		i1_n->dw0004 = 0x00;
		i0_n->dw0028 = i0_n->dw0028 & ~0x40000000 & ~0x20000000;
	}
	else
	{
		i0_n->ptr0004 = i1_n;
		word32 sp_n;
		word32 i0_n;
		word32 o0_n;
		word32 i1_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		byte Z_n;
		bool NV_n;
		fn00000FE8();
	}
}

// 00015550: void _obstack_newchunk(Register (ptr32 Eq_n) o0, Register word32 o1)
void _obstack_newchunk(Eq_n * o0, word32 o1)
{
	int32 l2_n = o0->dw000C - o0->dw0008;
	int32 o2_n = o0->dw0000;
	struct Eq_n * i0_n;
	Eq_n l2_n;
	int32 i1_n;
	struct Eq_n * l1_n;
	struct Eq_n * l0_n;
	if (o0->dw0028 < 0x00)
	{
		<anonymous> * o2_n = o0->ptr001C;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		bool NV_n;
		word32 l0_n;
		byte Z_n;
		bool NZV_n;
		byte N_n;
		word32 g2_n;
		o2_n();
		l0_n = o0_n;
	}
	else
	{
		<anonymous> * o1_n = o0->ptr001C;
		word32 sp_n;
		struct Eq_n * o0_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		bool NV_n;
		word32 l0_n;
		byte Z_n;
		bool NZV_n;
		byte N_n;
		word32 g2_n;
		o1_n();
		l0_n = o0_n;
	}
	if (l0_n == null)
	{
		<anonymous> * o1_n = globals->ptr2802C;
		word32 sp_n;
		word32 o0_n;
		word32 o1_n;
		word32 i2_n;
		word32 o2_n;
		word32 i3_n;
		word32 o3_n;
		word32 i4_n;
		word32 o4_n;
		word32 i5_n;
		word32 o5_n;
		word32 i6_n;
		word32 i7_n;
		word32 o7_n;
		word32 g0_n;
		byte NZVC_n;
		bool NV_n;
		byte Z_n;
		bool NZV_n;
		byte N_n;
		word32 g2_n;
		o1_n();
		i0_n->ptr0004 = l0_n;
	}
	else
		i0_n->ptr0004 = l0_n;
	word32 g2_n;
	Eq_n i1_n[];
	int32 o0_n;
	l0_n->ptr0004 = l1_n;
	ptr32 o1_n = l0_n + i1_n / 0x08;
	i0_n->ptr0010 = o1_n;
	l0_n->ptr0000 = o1_n;
	if (i0_n->dw0018 > 0x06)
	{
		Eq_n o0_n = l2_n >> 0x02;
		i1_n = (Eq_n (*)[]) ((char *) &l0_n->ptr0004 + 0x04);
		int32 o3_n = (word32) o0_n - 0x01;
		if (o0_n >= ~0x00)
		{
			g2_n = (char *) &l1_n->ptr0004 + 0x04;
			word32 * o4_n = l0_n + (((word32) o0_n - 0x01 << 0x02) + 0x08) / 0x08;
			while (true)
			{
				*o4_n = (word32) i0_n->ptr0008[o3_n];
				o3_n += ~0x00;
				if (o3_n < 0x00)
					break;
				o4_n += -0x01;
			}
		}
		else
			g2_n = (char *) &l1_n->ptr0004 + 0x04;
		o0_n = o0_n << 0x02;
	}
	else
	{
		o0_n = 0x00;
		i1_n = (Eq_n (*)[]) ((char *) &l0_n->ptr0004 + 0x04);
		g2_n = (char *) &l1_n->ptr0004 + 0x04;
	}
	Eq_n (* o0_n)[];
	int32 o3_n = o0_n;
	if (o0_n - l2_n < 0x00)
	{
		Eq_n o0_n[] = i0_n->ptr0008;
		while (true)
		{
			i1_n[o3_n / 0x04].u0 = (byte) (word32) o0_n[o3_n / 0x04];
			++o3_n;
			if (o3_n - l2_n >= 0x00)
				break;
			o0_n = i0_n->ptr0008;
		}
		o0_n = i0_n->ptr0008;
	}
	else
		o0_n = i0_n->ptr0008;
	Eq_n o0_n;
	if (o0_n - g2_n == 0x00)
	{
		Eq_n o0_n = i0_n->t0028;
		if ((o0_n >> 0x1E & 0x01) == 0x00)
		{
			l0_n->ptr0004 = l1_n->ptr0004;
			if (i0_n->t0028 >= 0x00)
			{
				<anonymous> * o1_n = i0_n->ptr0020;
				word32 sp_n;
				word32 o0_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NV_n;
				word32 l1_n;
				word32 l0_n;
				byte Z_n;
				bool NZV_n;
				byte N_n;
				word32 g2_n;
				o1_n();
				o0_n = i0_n->t0028;
			}
			else
			{
				<anonymous> * o2_n = i0_n->ptr0020;
				word32 sp_n;
				word32 o0_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NV_n;
				word32 l1_n;
				word32 l0_n;
				byte Z_n;
				bool NZV_n;
				byte N_n;
				word32 g2_n;
				o2_n();
				o0_n = i0_n->t0028;
			}
		}
		else
			o0_n = i0_n->t0028;
	}
	else
		o0_n = i0_n->t0028;
	i0_n->t0028 = o0_n & ~0x40000000;
	Mem136[i0_n + 0x0C:word32] = i1_n + l2_n;
	i0_n->ptr0008 = i1_n;
}

// 000156F0: void _obstack_allocated_p(Register (ptr32 Eq_n) o0, Register up32 o1)
void _obstack_allocated_p(Eq_n * o0, up32 o1)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
	{
		up32 g0_n = g3_n - o1;
		if (g0_n < 0x00)
		{
			if (g3_n->dw0000 - o1 >= 0x00)
				return;
			g3_n = g3_n->ptr0004;
			continue;
		}
	}
}

// 00015724: void _obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1)
void _obstack_free(Eq_n * o0, up32 o1)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n - i1_n >= 0x00)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			word32 sp_n;
			word32 o0_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			byte C_n;
			bool NV_n;
			o2_n();
			o1_n = i0_n->dw0028;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			word32 sp_n;
			word32 o0_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			byte C_n;
			bool NV_n;
			o1_n();
			o1_n = i0_n->dw0028;
		}
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 000157D4: void obstack_free(Register (ptr32 Eq_n) o0, Register up32 o1)
void obstack_free(Eq_n * o0, up32 o1)
{
	struct Eq_n * i0_n = o0;
	up32 i1_n = o1;
	up32 * o3_n = o0->ptr0004;
	while (o3_n != null)
	{
		up32 g0_n = o3_n - i1_n;
		int32 o0_n;
		if (g0_n < 0x00)
		{
			if (*o3_n - i1_n >= 0x00)
				break;
			o0_n = i0_n->dw0028;
		}
		else
			o0_n = i0_n->dw0028;
		int32 o1_n;
		up32 * l0_n;
		if (o0_n < 0x00)
		{
			<anonymous> * o2_n = i0_n->ptr0020;
			word32 sp_n;
			word32 o0_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			byte C_n;
			bool NV_n;
			o2_n();
			o1_n = i0_n->dw0028;
		}
		else
		{
			<anonymous> * o1_n = i0_n->ptr0020;
			word32 sp_n;
			word32 o0_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			byte C_n;
			bool NV_n;
			o1_n();
			o1_n = i0_n->dw0028;
		}
		i0_n->dw0028 = o1_n | 0x40000000;
		o3_n = l0_n;
	}
	if (o3_n == null)
	{
		if (i1_n == 0x00)
			return;
		abort();
	}
	else
	{
		i0_n->dw0008 = i1_n;
		i0_n->dw000C = i1_n;
		up32 o0_n = *o3_n;
		i0_n->ptr0004 = o3_n;
		i0_n->dw0010 = o0_n;
	}
}

// 00015884: void _obstack_memory_used(Register (ptr32 Eq_n) o0)
void _obstack_memory_used(Eq_n * o0)
{
	struct Eq_n * g3_n;
	for (g3_n = o0->ptr0004; g3_n != null; g3_n = g3_n->ptr0004)
		;
}

// 000158B4: void print_and_abort()
void print_and_abort()
{
	fputs("memory exhausted\n", &globals->t2B640);
	exit(globals->dw28030);
}

// 000158D8: Register Eq_n try(Register Eq_n o0, Register Eq_n o1)
Eq_n try(Eq_n o0, Eq_n o1)
{
	Eq_n i0_n = o0;
	if (o1 != 0x00)
		i0_n = o1;
	else if (o0 == 0x00 || access(o0, 0x07) != 0x00)
		&i0_n.u0->b0000 = 0x00;
	return i0_n;
}

// 00015918: Register Eq_n choose_temp_base(Register out ptr32 l0Out, Register out ptr32 l1Out, Register out ptr32 i0Out, Register out ptr32 i6Out)
Eq_n choose_temp_base(ptr32 & l0Out, ptr32 & l1Out, ptr32 & i0Out, ptr32 & i6Out)
{
	Eq_n o0_n = try(0x00028038, try(0x00028040, try(0x00017900, try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), 0x00))))));
	Eq_n l0_n;
	*l0Out = o0_n;
	if (o0_n == 0x00)
		*l0Out = 0x00017910;
	word32 o0_n;
	Eq_n o0_n = strlen(l0_n);
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	word32 o0_n = xmalloc(o0_n + 0x0A, out i0_n, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n, l0_n);
	Eq_n l1_n = o0_n;
	*l1Out = l1_n;
	word32 i0_n;
	*i0Out = o0_n;
	if (o0_n != 0x00)
	{
		if ((int32) Mem0[o0_n + o0_n + -0x01:int8] == 0x2F)
		{
			o0_n = (word32) globals->b17918;
l00015A04:
			Mem78[o0_n + l1_n:byte] = (byte) o0_n;
			word32 o4_n = o0_n + l1_n;
			(&o4_n->b0000)[0x01] = (byte) (word32) globals->b17919;
			(&o4_n->b0000)[0x02] = (byte) (word32) globals->b1791A;
			(&o4_n->b0000)[0x03] = (byte) (word32) globals->b1791B;
			(&o4_n->b0000)[0x04] = (byte) (word32) globals->b1791C;
			(&o4_n->b0000)[0x05] = (byte) (word32) globals->b1791D;
			(&o4_n->b0000)[0x06] = (byte) (word32) globals->b1791E;
			(&o4_n->b0000)[0x07] = (byte) (word32) globals->b1791F;
			(&o4_n->b0000)[0x08] = (byte) (word32) globals->b17920;
			mktemp(o0_n);
			if (strlen(o0_n) != 0x00)
				return o0_n;
			abort();
		}
		Mem132[o0_n + o0_n:byte] = 0x2F;
		*l1Out = o0_n + 0x01;
	}
	o0_n = (word32) globals->b17918;
	goto l00015A04;
}

// 00015A7C: void make_temp_file(Register word32 o0)
void make_temp_file(word32 o0)
{
	Eq_n o0_n = try(0x00028050, try(0x00028058, try(0x00017900, try(getenv("TEMP"), try(getenv("TMP"), try(getenv("TMPDIR"), 0x00))))));
	Eq_n l0_n = o0_n;
	if (o0_n == 0x00)
		&l0_n.u0->b0000 = 0x00017910;
	Eq_n l2_n;
	Eq_n o0_n = strlen(l0_n);
	if (0x00017800 != 0x00)
		l2_n = strlen(0x00017800);
	else
		&l2_n.u0->b0000 = 0x00;
	word32 i0_n;
	word32 i1_n;
	word32 i2_n;
	word32 i6_n;
	word32 o0_n = xmalloc(o0_n + l2_n + 0x0A, out i0_n, out i1_n, out i2_n, out i6_n);
	strcpy(o0_n, l0_n);
	Eq_n l1_n = o0_n;
	if (o0_n != 0x00)
	{
		word32 o0_n = o0_n + o0_n;
		if ((int32) o0_n->bFFFFFFFF != 0x2F)
		{
			Mem138[o0_n + o0_n:byte] = 0x2F;
			l1_n = o0_n + 0x01;
		}
	}
	Mem87[o0_n + l1_n:byte] = (byte) (word32) Mem0[0x00017918:byte];
	word32 o3_n = o0_n + l1_n;
	o3_n->b0001 = (byte) (word32) globals->b17919;
	o3_n->b0002 = (byte) (word32) globals->b1791A;
	o3_n->b0003 = (byte) (word32) globals->b1791B;
	o3_n->b0004 = (byte) (word32) globals->b1791C;
	o3_n->b0005 = (byte) (word32) globals->b1791D;
	o3_n->b0006 = (byte) (word32) globals->b1791E;
	o3_n->b0007 = (byte) (word32) globals->b1791F;
	word32 o1_n = (word32) globals->b17920;
	if (0x00017800 == 0x00)
	{
		o3_n->b0008 = (byte) o1_n;
		Eq_n o0_n = mkstemps(o0_n, l2_n);
		if (o0_n != ~0x00)
		{
			if (close(o0_n) == 0x00)
				return;
			abort();
		}
		else
			abort();
	}
	else
	{
		o3_n->b0008 = (byte) o1_n;
		strcat(o0_n, "e");
	}
}

// 00015C24: Register (ptr32 int8) my_index(Register (ptr32 int8) o0, Register Eq_n o1)
int8 * my_index(int8 * o0, Eq_n o1)
{
	int32 g2_n = (int32) *o0;
	while (g2_n != 0x00)
	{
		ui32 g3_n = (word32) *o0;
		if ((g3_n << 0x18 >> 0x18) - o1 == 0x00)
			return o0;
		++o0;
		g2_n = (int32) *o0;
	}
	o0 = null;
	return o0;
}

// 00015C60: Register (ptr32 (arr Eq_n)) exchange(Register (arr Eq_n) o0, Register out (ptr32 int8) i2Out, Register out (ptr32 word32) i4Out, Register out ptr32 i5Out, Register out (ptr32 Eq_n) i6Out)
Eq_n * exchange[](Eq_n o0[], int8 * & i2Out, word32 * & i4Out, ptr32 & i5Out, Eq_n * & i6Out)
{
	int32 g2_n;
	int32 g1_n = globals->dw2B300;
	int32 i5_n = globals->dw28068;
	*i5Out = i5_n;
	word32 i2_n = o2;
	*i2Out = i2_n;
	word32 i6_n;
	*i6Out = fp;
	Eq_n i1_n[] = &globals->t28000;
	int32 i4_n = globals->dw2B2F0;
	*i4Out = i4_n;
	if (i5_n - g1_n <= 0x00)
	{
l00015D40:
		g2_n = globals->dw28068;
		goto l00015D44;
	}
	if (g1_n - i4_n <= 0x00)
	{
		g2_n = globals->dw28068;
l00015D44:
		globals->dw2B2F0 += g2_n - globals->dw2B300;
		globals->dw2B300 = g2_n;
		return i1_n;
	}
	int32 g3_n = i5_n - g1_n;
l00015CA4:
	bool NZV_n;
	int32 g2_n = g1_n - i4_n;
	if (g3_n - g2_n > 0x00)
	{
		if (g2_n > 0x00)
		{
			i5_n -= g2_n;
			*i5Out = i5_n;
			int32 i3_n = g2_n;
			i1_n = i5_n << 0x02;
			Eq_n (* g3_n)[] = i4_n << 0x02;
			while (true)
			{
				word32 i2_n = Mem0[g3_n + o0:word32];
				*i2Out = i2_n;
				Mem137[g3_n + o0:word32] = Mem0[i1_n + o0:word32];
				Mem138[i1_n + o0:word32] = i2_n;
				i3_n += ~0x00;
				i1_n = (Eq_n (*)[]) (i1_n + 0x01);
				if (i3_n == 0x00)
					break;
				g3_n += 0x04;
			}
			NZV_n = (bool) cond(i5_n - g1_n);
l00015D30:
			if (NZV_n)
				goto l00015D40;
			int32 g0_n = g1_n - i4_n;
			if (g0_n <= 0x00)
				goto l00015D40;
			g3_n = i5_n - g1_n;
			goto l00015CA4;
		}
		*i5Out = i5_n - g2_n;
	}
	else
	{
		int32 g4_n;
		if (g3_n > 0x00)
		{
			g4_n = i4_n + g3_n;
			int32 i3_n = g3_n;
			int32 i1_n = i4_n << 0x02;
			int32 g3_n = g1_n << 0x02;
			while (true)
			{
				word32 i2_n = o0[i1_n / 0x04];
				*i2Out = i2_n;
				o0[i1_n / 0x04] = o0[g3_n / 0x04];
				o0[g3_n / 0x04] = i2_n;
				i3_n += ~0x00;
				g3_n += 0x04;
				if (i3_n == 0x00)
					break;
				i1_n += 0x04;
			}
			i1_n = i1_n + 0x04;
		}
		else
			g4_n = i4_n + g3_n;
		*i4Out = g4_n;
	}
	NZV_n = (bool) cond(i5_n - g1_n);
	goto l00015D30;
}

// 00015D64: Register (ptr32 int8) _getopt_initialize(Register (ptr32 int8) o2, Register out ptr32 i1Out, Register out ptr32 i4Out, Register out ptr32 i5Out, Register out ptr32 i6Out)
int8 * _getopt_initialize(int8 * o2, ptr32 & i1Out, ptr32 & i4Out, ptr32 & i5Out, ptr32 & i6Out)
{
	int32 o2_n = globals->dw28068;
	globals->dw2B2F0 = o2_n;
	globals->dw2B300 = o2_n;
	&globals->t2B2C0.u0->b0000 = 0x00;
	Eq_n o0_n = getenv("POSIXLY_CORRECT");
	globals->t2B2E0 = o0_n;
	word32 i1_n;
	*i1Out = o1;
	word32 i4_n;
	*i4Out = o4;
	word32 i5_n;
	*i5Out = o5;
	word32 i6_n;
	*i6Out = fp;
	int8 * i0_n = o2;
	int32 o0_n = (int32) *o2;
	if (o0_n == 0x2D)
	{
		globals->dw2B2D0 = 0x02;
		i0_n = o2 + 0x01;
	}
	else if (o0_n == 0x2B)
	{
		globals->dw2B2D0 = 0x00;
		i0_n = o2 + 0x01;
	}
	else if (o0_n != 0x00)
		globals->dw2B2D0 = 0x00;
	else
		globals->dw2B2D0 = 0x01;
	return i0_n;
}

// 00015E04: Register Eq_n _getopt_internal(Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register (ptr32 word32) o4, Register word32 o5, Stack word32 dwArg44, Stack word32 dwArg50, Register out ptr32 l0Out, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out ptr32 i6Out)
Eq_n _getopt_internal(Eq_n * o1[], int8 * o2, word32 * o4, word32 o5, word32 dwArg44, word32 dwArg50, ptr32 & l0Out, ptr32 & l6Out, ptr32 & l7Out, ptr32 & i6Out)
{
	*l7Out = l7;
	int32 o2_n = globals->dw28068;
	&globals->t28064.u0->b0000 = 0x00;
	Eq_n i1_n[] = o1;
	int8 * i2_n = o2;
	word32 * i4_n = o4;
	word32 i5_n = o5;
	struct Eq_n * i6_n;
	*i6Out = fp;
	Eq_n Z_n = cond(o2_n);
	if (o2_n != 0x00)
	{
		if (globals->dw2806C != 0x00)
			goto l00015E74;
		Z_n = cond(o2_n);
	}
	if (!Z_n)
		globals->dw28068 = 0x01;
	int8 * o0_n = _getopt_initialize(o2, out i1_n, out i4_n, out i5_n, out i6_n);
	globals->dw2806C = 0x01;
	i2_n = o0_n;
l00015E74:
	struct Eq_n * o0_n;
	Eq_n i0_n;
	word32 l0_n;
	*l0Out = 0x00028000;
	word32 l6_n;
	*l6Out = 0x0002B000;
	Eq_n o0_n = globals->t2B2C0;
	if (o0_n != 0x00 && (int32) (*o0_n) != 0x00)
	{
		o0_n = i6_n->ptr0050;
		goto l000160C0;
	}
	int32 o2_n = globals->dw28068;
	if (globals->dw2B300 - o2_n > 0x00)
		globals->dw2B300 = o2_n;
	word32 l0_n = 0x0002B000;
	*l0Out = l0_n;
	if (globals->dw2B2F0 - o2_n > 0x00)
		globals->dw2B2F0 = o2_n;
	if (globals->dw2B2D0 != 0x01)
	{
l00015F78:
		int32 o2_n;
		int32 o1_n = globals->dw28068;
		if (o1_n - i6_n->dw0044 == 0x00)
		{
l00016008:
			o2_n = globals->dw28068;
			goto l0001600C;
		}
		if (strcmp(i1_n[o1_n], 96568) != 0x00)
		{
			o2_n = globals->dw28068;
l0001600C:
			if (o2_n - i6_n->dw0044 == 0x00)
			{
				int32 o1_n = globals->dw2B2F0;
				if (o1_n - globals->dw2B300 == 0x00)
				{
					i0_n.u0 = ~0x00;
					return i0_n;
				}
				globals->dw28068 = o1_n;
			}
			else
			{
				int32 o0_n = o2_n << 0x02;
				word32 o0_n;
				Eq_n o3_n = i1_n[o0_n / 0x04];
				if ((int32) *o3_n == 0x2D)
				{
					int32 o0_n = (int32) *((word32) o3_n + 0x01);
					if (o0_n != 0x00)
					{
						struct Eq_n * o2_n = i6_n->ptr0050;
						word32 o1_n;
						if (o2_n != null)
							o1_n = 0x01 - ((o0_n ^ 0x2D) > 0x00);
						else
							o1_n = 0x00;
						globals->t2B2C0 = (word32) o3_n + (o1_n + 0x01);
						o0_n = i6_n->ptr0050;
l000160C0:
						Eq_n o1_n;
						int32 o0_n;
						union Eq_n * o1_n;
						Eq_n o0_n;
						if (o0_n == null)
						{
							o1_n = globals->t2B2C0;
							goto l000164A0;
						}
						int32 o0_n = globals->dw28068;
						Eq_n l2_n;
						Eq_n o0_n = i1_n[o0_n];
						Eq_n o1_n = (int32) *((word32) o0_n + 0x01);
						if (o1_n != 0x2D)
						{
							if (i5_n == 0x00)
							{
								o1_n = globals->t2B2C0;
								goto l000164A0;
							}
							if ((int32) *((word32) o0_n + 0x02) != 0x00)
							{
								l2_n = globals->t2B2C0;
l00016114:
								struct Eq_n * l3_n = null;
								word32 i3_n = 0x00;
								int32 o0_n = (int32) *l2_n;
								word32 i0_n = 0x00;
								word32 o1_n = i6_n->ptr0050->dw0000;
								word32 l7_n = ~0x00;
								*l7Out = l7_n;
								while (o0_n != 0x00)
								{
									int32 g0_n = o0_n - 0x3D;
									if (g0_n == 0x00)
										break;
									l2_n = (word32) l2_n + 0x01;
									o0_n = (int32) *l2_n;
								}
								struct Eq_n * l1_n = i6_n->ptr0050;
								if (o1_n != 0x00)
								{
									word32 l4_n = 0x00;
l0001615C:
									Eq_n o1_n = globals->t2B2C0;
									if (strncmp(l1_n->dw0000, o1_n, l2_n - o1_n) != 0x00)
									{
										++l1_n;
										goto l000161A8;
									}
									ptr32 l0_n = l2_n - globals->t2B2C0;
									*l0Out = l0_n;
									if (l0_n - strlen(l1_n->dw0000) != 0x00)
									{
										if (l3_n == null)
										{
											l3_n = l1_n;
											*l7Out = l4_n;
										}
										else
											i0_n = 0x01;
										++l1_n;
l000161A8:
										if (l1_n->dw0000 == 0x00)
											goto l000161B8;
										++l4_n;
										goto l0001615C;
									}
									l3_n = l1_n;
									*l7Out = l4_n;
									i3_n = 0x01;
								}
l000161B8:
								Eq_n Z_n;
								if (i0_n != 0x00)
								{
									if (i3_n == 0x00)
									{
										if (globals->dw28070 == 0x00)
										{
											Eq_n o0_n = strlen(globals->t2B2C0);
											int32 o2_n = globals->dw28068;
											Mem950[0x0002B2C0:word32] = Mem26[0x0002B2C0:word32] + o0_n;
											globals->dw28068 = o2_n + 0x01;
											globals->t28074.u0 = 0x00;
											i0_n.u0 = 0x3F;
											return i0_n;
										}
										else
										{
											int32 o1_n = globals->dw28068;
											fprintf(&globals->t2B640, "%s: option `%s' is ambiguous\n", i1_n[0x00], i1_n[o1_n]);
										}
									}
									Z_n = cond(l3_n);
								}
								else
									Z_n = cond(l3_n);
								if (!Z_n)
								{
									int32 o2_n = globals->dw28068;
									globals->dw28068 = o2_n + 0x01;
									if ((int32) *l2_n != 0x00)
									{
										word32 o0_n = l3_n->dw0004;
										if (o0_n != 0x00)
										{
											Eq_n o0_n = (word32) l2_n + 0x01;
											globals->t28064 = o0_n;
										}
										else if (globals->dw28070 != 0x00)
										{
											Eq_n o0_n;
											struct Eq_n * o3_n = (i1_n + (o2_n + 0x01 << 0x02) / 0x04)[-0x01];
											if ((int32) o3_n->b0001 == 0x2D)
											{
												fprintf(&globals->t2B640, "%s: option `--%s' doesn't allow an argument\n", i1_n[0x00], l3_n->dw0000);
												o0_n = globals->t2B2C0;
											}
											else
											{
												fprintf(&globals->t2B640, "%s: option `%c%s' doesn't allow an argument\n", i1_n[0x00], (int32) o3_n->b0000, l3_n->dw0000);
												o0_n = globals->t2B2C0;
											}
											Eq_n o0_n = strlen(o0_n);
											Eq_n o2_n = l3_n->t000C;
											Mem783[0x0002B2C0:word32] = Mem729[0x0002B2C0:word32] + o0_n;
											globals->t28074 = o2_n;
											i0_n.u0 = 0x3F;
											return i0_n;
										}
l00016398:
										word32 o1_n = Mem729[0x0002B2C0:word32] + strlen(globals->t2B2C0);
										if (i4_n != null)
										{
											globals->t2B2C0 = o1_n;
											*i4_n = l7_n;
										}
										else
											globals->t2B2C0 = o1_n;
										o1_n = l3_n->ptr0008;
										if (o1_n == null)
										{
											i0_n = l3_n->t000C;
											return i0_n;
										}
										o0_n = l3_n->t000C;
										goto l00016874;
									}
									word32 o0_n = l3_n->dw0004;
									if (o0_n != 0x01)
										goto l00016398;
									int32 o0_n = i6_n->dw0044;
									if (o2_n + 0x01 - o0_n < 0x00)
									{
										globals->t28064 = i1_n[o2_n + 0x01];
										globals->dw28068 = o2_n + 0x02;
										goto l00016398;
									}
									if (globals->dw28070 != 0x00)
										fprintf(&globals->t2B640, "%s: option `%s' requires an argument\n", i1_n[0x00], (i1_n + (o2_n + 0x01 << 0x02) / 0x04)[-0x01]);
									Eq_n o0_n = strlen(globals->t2B2C0);
									Eq_n o2_n = l3_n->t000C;
									Mem843[0x0002B2C0:word32] = Mem729[0x0002B2C0:word32] + o0_n;
									globals->t28074 = o2_n;
									o0_n = (int32) *i2_n;
l00016388:
									i0_n.u0 = 0x3F;
									if (o0_n != 0x3A)
										strlen(globals->t2B2C0);
									else
										i0_n.u0 = 0x3A;
									return i0_n;
								}
								if (i5_n == 0x00)
								{
l0001640C:
									int32 o0_n;
									if (globals->dw28070 != 0x00)
									{
										int32 o0_n = globals->dw28068;
										Eq_n o3_n = i1_n[o0_n];
										if ((int32) *((word32) o3_n + 0x01) != 0x2D)
											fprintf(&globals->t2B640, "%s: unrecognized option `%c%s'\n", i1_n[0x00], (int32) *o3_n, globals->t2B2C0);
										fprintf(&globals->t2B640, "%s: unrecognized option `--%s'\n", i1_n[0x00], globals->t2B2C0);
										o0_n = globals->dw28068;
									}
									else
										o0_n = globals->dw28068;
									&globals->t2B2C0.u0->b0000 = 96808;
									globals->dw28068 = o0_n + 0x01;
									globals->t28074.u0 = 0x00;
									i0_n.u0 = 0x3F;
									return i0_n;
								}
								int32 o0_n = globals->dw28068;
								if ((int32) *((word32) i1_n[o0_n] + 0x01) == 0x2D)
									goto l0001640C;
								Eq_n o2_n = globals->t2B2C0;
								if (my_index(i2_n, (int32) *o2_n) == null)
									goto l0001640C;
								o1_n = globals->t2B2C0;
l000164A0:
								Eq_n Z_n;
								ui32 i0_n = (word32) *o1_n;
								globals->t2B2C0 = (word32) o1_n + 0x01;
								Eq_n l0_n = i0_n << 0x18 >> 0x18;
								*l0Out = l0_n;
								struct Eq_n * o0_n = my_index(i2_n, l0_n);
								Eq_n o3_n = globals->t2B2C0;
								if ((int32) *o3_n == 0x00)
								{
									Z_n = cond(o0_n);
									++globals->dw28068;
								}
								else
									Z_n = cond(o0_n);
								if (Z_n || l0_n == 0x3A)
								{
									if (globals->dw28070 != 0x00)
									{
										if (globals->t2B2E0 == 0x00)
											fprintf(&globals->t2B640, "%s: invalid option -- %c\n", i1_n[0x00], l0_n);
										fprintf(&globals->t2B640, "%s: illegal option -- %c\n", i1_n[0x00], l0_n);
									}
									globals->t28074 = i0_n << 0x18 >> 0x18;
									i0_n.u0 = 0x3F;
									return i0_n;
								}
								int32 o0_n = (int32) o0_n->b0000;
								int32 o0_n;
								int32 i0_n;
								if (o0_n == 0x57)
								{
									ui32 o1_n = (word32) o0_n->b0001;
									if (o1_n == 0x3B)
									{
										struct Eq_n * l3_n = null;
										word32 i0_n = 0x00;
										word32 l4_n = 0x00;
										if ((int32) *o3_n != 0x00)
										{
											int32 o0_n = globals->dw28068;
											globals->t28064 = o3_n;
											globals->dw28068 = o0_n + 0x01;
											goto l0001663C;
										}
										word32 l7_n;
										*l7Out = 0x00;
										int32 o2_n = globals->dw28068;
										if (o2_n - i6_n->dw0044 != 0x00)
										{
											globals->t28064 = i1_n[o2_n];
											globals->dw28068 = o2_n + 0x01;
l0001663C:
											Eq_n l1_n = globals->t28064;
											globals->t2B2C0 = l1_n;
											word32 l7_n = 0x00;
											*l7Out = l7_n;
											while (true)
											{
												int32 o0_n = (int32) *l1_n;
												if (o0_n == 0x00 || o0_n == 0x3D)
													break;
												l1_n = (word32) l1_n + 0x01;
											}
											struct Eq_n * i3_n = i6_n->ptr0050;
											if (i3_n->dw0000 != 0x00)
											{
												word32 l2_n = 0x00;
l00016670:
												Eq_n o1_n = globals->t2B2C0;
												if (strncmp(i3_n->dw0000, o1_n, l1_n - o1_n) != 0x00)
												{
													++i3_n;
													goto l000166BC;
												}
												ptr32 l0_n = l1_n - globals->t2B2C0;
												*l0Out = l0_n;
												if (l0_n - strlen(i3_n->dw0000) != 0x00)
												{
													if (l3_n == null)
													{
														l3_n = i3_n;
														*l7Out = l2_n;
													}
													else
														l4_n = 0x01;
													++i3_n;
l000166BC:
													if (i3_n->dw0000 == 0x00)
														goto l000166CC;
													++l2_n;
													goto l00016670;
												}
												l3_n = i3_n;
												*l7Out = l2_n;
												i0_n = 0x01;
											}
l000166CC:
											Eq_n Z_n;
											if (l4_n != 0x00)
											{
												if (i0_n == 0x00)
												{
													if (globals->dw28070 == 0x00)
													{
														Eq_n o0_n = strlen(globals->t2B2C0);
														int32 o2_n = globals->dw28068;
														Mem518[0x0002B2C0:word32] = Mem351[0x0002B2C0:word32] + o0_n;
														globals->dw28068 = o2_n + 0x01;
														i0_n.u0 = 0x3F;
														return i0_n;
													}
													else
													{
														int32 o1_n = globals->dw28068;
														fprintf(&globals->t2B640, "%s: option `-W %s' is ambiguous\n", i1_n[0x00], i1_n[o1_n]);
													}
												}
												Z_n = cond(l3_n);
											}
											else
												Z_n = cond(l3_n);
											if (Z_n)
											{
												&globals->t2B2C0.u0->b0000 = 0x00;
												i0_n.u0 = 0x57;
												return i0_n;
											}
											if ((int32) *l1_n != 0x00)
											{
												word32 o0_n = l3_n->dw0004;
												if (o0_n == 0x00)
												{
													if (globals->dw28070 == 0x00)
													{
														Mem442[0x0002B2C0:word32] = Mem351[0x0002B2C0:word32] + strlen(globals->t2B2C0);
														i0_n.u0 = 0x3F;
														return i0_n;
													}
													else
														fprintf(&globals->t2B640, "%s: option `-W %s' doesn't allow an argument\n", i1_n[0x00], l3_n->dw0000);
												}
												Eq_n o0_n = (word32) l1_n + 0x01;
												globals->t28064 = o0_n;
											}
											else
											{
												word32 o0_n = l3_n->dw0004;
												if (o0_n == 0x01)
												{
													int32 o2_n = globals->dw28068;
													if (o2_n - i6_n->dw0044 >= 0x00)
													{
														if (globals->dw28070 != 0x00)
															fprintf(&globals->t2B640, "%s: option `%s' requires an argument\n", i1_n[0x00], (i1_n + (o2_n << 0x02) / 0x04)[-0x01]);
														Mem481[0x0002B2C0:word32] = Mem351[0x0002B2C0:word32] + strlen(globals->t2B2C0);
														o0_n = (int32) *i2_n;
														goto l00016388;
													}
													globals->t28064 = i1_n[o2_n];
													globals->dw28068 = o2_n + 0x01;
												}
											}
											word32 o1_n = Mem351[0x0002B2C0:word32] + strlen(globals->t2B2C0);
											if (i4_n != null)
											{
												globals->t2B2C0 = o1_n;
												*i4_n = l7_n;
											}
											else
												globals->t2B2C0 = o1_n;
											o1_n = l3_n->ptr0008;
											if (o1_n == null)
											{
												i0_n = l3_n->t000C;
												return i0_n;
											}
											o0_n = l3_n->t000C;
l00016874:
											*o1_n = (union Eq_n *) o0_n;
											i0_n.u0 = 0x00;
											return i0_n;
										}
										if (globals->dw28070 != 0x00)
											fprintf(&globals->t2B640, "%s: option requires an argument -- %c\n", i1_n[0x00], l0_n);
										globals->t28074 = l0_n;
										if ((int32) *i2_n == 0x3A)
											i0_n = 0x3A;
										else
											i0_n = 0x3F;
l00016970:
										i0_n = i0_n << 0x18;
l00016974:
										i0_n = i0_n >> 0x18;
										return i0_n;
									}
									o0_n = o1_n << 0x18;
								}
								else
								{
									ui32 o1_n = (word32) o0_n->b0001;
									o0_n = o1_n << 0x18;
								}
								if (o0_n >> 0x18 != 0x3A)
								{
									i0_n = i0_n << 0x18;
									goto l00016974;
								}
								Eq_n o1_n;
								int32 o0_n;
								if ((int32) o0_n->b0002 == 0x3A)
								{
									o1_n = globals->t2B2C0;
									if ((int32) *o1_n == 0x00)
									{
										&globals->t28064.u0->b0000 = 0x00;
										goto l0001696C;
									}
									o0_n = globals->dw28068;
								}
								else
								{
									o1_n = globals->t2B2C0;
									if ((int32) *o1_n == 0x00)
									{
										int32 o2_n = globals->dw28068;
										if (o2_n - i6_n->dw0044 == 0x00)
										{
											if (globals->dw28070 != 0x00)
												fprintf(&globals->t2B640, "%s: option requires an argument -- %c\n", i1_n[0x00], i0_n << 0x18 >> 0x18);
											globals->t28074 = i0_n << 0x18 >> 0x18;
											if ((int32) *i2_n == 0x3A)
												i0_n = 0x3A;
											else
												i0_n = 0x3F;
										}
										else
										{
											globals->t28064 = i1_n[o2_n];
											globals->dw28068 = o2_n + 0x01;
										}
l0001696C:
										&globals->t2B2C0.u0->b0000 = 0x00;
										goto l00016970;
									}
									o0_n = globals->dw28068;
								}
								globals->t28064 = o1_n;
								globals->dw28068 = o0_n + 0x01;
								goto l0001696C;
							}
							if (my_index(i2_n, o1_n) != null)
							{
								o1_n = globals->t2B2C0;
								goto l000164A0;
							}
						}
						l2_n = globals->t2B2C0;
						goto l00016114;
					}
					o0_n = globals->dw2B2D0;
				}
				else
					o0_n = globals->dw2B2D0;
				if (o0_n != 0x00)
				{
					int32 o0_n = o2_n + 0x01;
					globals->t28064 = o3_n;
					globals->dw28068 = o0_n;
					i0_n.u0 = 0x01;
					return i0_n;
				}
			}
			i0_n.u0 = ~0x00;
			return i0_n;
		}
		int32 o1_n;
		int32 o0_n;
		int32 o2_n = globals->dw2B300;
		int32 o0_n = globals->dw28068;
		if (globals->dw2B2F0 - o2_n != 0x00)
		{
			globals->dw28068 = o0_n + 0x01;
			if (o2_n - (o0_n + 0x01) != 0x00)
			{
				i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
				o0_n = i6_n->dw0044;
				goto l00016000;
			}
			o1_n = globals->dw2B2F0;
		}
		else
		{
			globals->dw28068 = o0_n + 0x01;
			o1_n = globals->dw2B2F0;
		}
		if (o1_n - globals->dw2B300 == 0x00)
		{
			globals->dw2B2F0 = globals->dw28068;
			o0_n = i6_n->dw0044;
		}
		else
			o0_n = i6_n->dw0044;
l00016000:
		globals->dw2B300 = o0_n;
		globals->dw28068 = o0_n;
		goto l00016008;
	}
	int32 o0_n;
	int32 o1_n = globals->dw2B300;
	if (globals->dw2B2F0 - o1_n != 0x00)
	{
		word32 g0_n = o1_n - o2_n;
		if (g0_n != 0x00)
		{
			i1_n = exchange(i1_n, out i2_n, out i4_n, out i5_n, out i6_n);
			goto l00015F24;
		}
		o0_n = globals->dw2B300;
	}
	else
		o0_n = globals->dw2B300;
	int32 o1_n = globals->dw28068;
	if (o0_n - o1_n != 0x00)
		globals->dw2B2F0 = o1_n;
l00015F24:
	int32 o2_n = globals->dw28068;
	bool NV_n = (bool) cond(o2_n - i6_n->dw0044);
	while (!NV_n)
	{
		int32 o0_n = o2_n << 0x02;
		int32 o0_n;
		struct Eq_n * o0_n = i1_n[o0_n / 0x04];
		if ((int32) o0_n->b0000 == 0x2D)
		{
			if ((int32) o0_n->b0001 != 0x00)
				break;
			o0_n = globals->dw28068;
		}
		else
			o0_n = globals->dw28068;
		int32 o0_n = o0_n + 0x01;
		int32 o1_n = i6_n->dw0044;
		globals->dw28068 = o0_n;
		o2_n = o0_n;
		NV_n = (bool) cond(o0_n - o1_n);
	}
	globals->dw2B300 = o2_n;
	goto l00015F78;
}

// 00016980: void getopt(Register word32 o0, Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2)
void getopt(word32 o0, Eq_n * o1[], int8 * o2)
{
	word32 l0_n;
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, null, 0x00, dwLoc2C, dwLoc20, out l0_n, out l6_n, out l7_n, out i6_n);
}

// 000169A8: Register word32 getopt_long(Register word32 o0, Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register word32 o3, Register (ptr32 word32) o4, Register out ptr32 l6Out, Register out ptr32 l7Out, Register out ptr32 i6Out)
word32 getopt_long(word32 o0, Eq_n * o1[], int8 * o2, word32 o3, word32 * o4, ptr32 & l6Out, ptr32 & l7Out, ptr32 & i6Out)
{
	word32 l0_n;
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, o4, 0x00, dwLoc2C, dwLoc20, out l0_n, out l6_n, out l7_n, out i6_n);
	return l0_n;
}

// 000169D0: void getopt_long_only(Register word32 o0, Register (ptr32 (arr Eq_n)) o1, Register (ptr32 int8) o2, Register word32 o3, Register (ptr32 word32) o4)
void getopt_long_only(word32 o0, Eq_n * o1[], int8 * o2, word32 o3, word32 * o4)
{
	word32 l0_n;
	word32 l6_n;
	word32 l7_n;
	word32 i6_n;
	_getopt_internal(o1, o2, o4, 0x01, dwLoc2C, dwLoc20, out l0_n, out l6_n, out l7_n, out i6_n);
}

// 000169F8: Register Eq_n pexecute(Register Eq_n o0, Register (ptr32 char) o2, Register (ptr32 word32) o4, Register (ptr32 word32) o5, Register Eq_n l1, Stack word32 dwArg44, Stack Eq_n dwArg48, Stack word32 dwArg4C, Stack word32 dwArg54, Stack word32 dwArg58, Stack ui32 dwArg5C, Register out ptr32 l0Out, Register out ptr32 i6Out)
pid_t pexecute(pid_t o0, char * o2, word32 * o4, word32 * o5, pid_t l1, word32 dwArg44, Eq_n dwArg48, word32 dwArg4C, word32 dwArg54, word32 dwArg58, ui32 dwArg5C, ptr32 & l0Out, ptr32 & i6Out)
{
	ptr32 i6_n = fp;
	*i6Out = i6_n;
	if ((dwArg5C & 0x01) != 0x00)
		&globals->t2B310.u0->b0000 = 0x00;
	Eq_n dwLoc24_n;
	word32 o0_n;
	Eq_n i0_n;
	word32 l0_n = 0x0002B000;
	*l0Out = l0_n;
	Eq_n o0_n = globals->t2B310;
	if ((dwArg5C & 0x02) == 0x00)
	{
		if (pipe(fp + ~0x17) < 0x00)
		{
			o0_n = 0x00017B18;
			goto l00016B10;
		}
		globals->t2B310 = dwLoc18;
		dwLoc24_n = dwLoc14;
	}
	else
	{
		&globals->t2B310.u0->b0000 = 0x00;
		&dwLoc24_n.u0->b0000 = 0x01;
	}
	uint32 dwLoc2C_n = 0x01;
	int32 dwLoc28_n = 0x00;
	while (true)
	{
		Eq_n Z_n;
		if (dwLoc28_n > 0x03)
			break;
		Eq_n o0_n = vfork();
		l1 = o0_n;
		if (o0_n >= 0x00)
		{
			Z_n = cond(o0_n - ~0x00);
			goto l00016AEC;
		}
		sleep(dwLoc2C_n);
		dwLoc2C_n <<= 0x01;
		++dwLoc28_n;
	}
	Z_n = cond(l1 - ~0x00);
l00016AEC:
	if (!Z_n)
	{
		if (l1 == 0x00)
		{
			if (o0_n != 0x00)
			{
				close(0x00);
				dup(o0_n);
				close(o0_n);
			}
			if (dwLoc24_n != 0x01)
			{
				close(0x01);
				dup(dwLoc24_n);
				close(dwLoc24_n);
			}
			Eq_n o0_n = globals->t2B310;
			if (o0_n != 0x00)
				close(o0_n);
			word32 sp_n;
			word32 i0_n;
			word32 o0_n;
			word32 i1_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			word32 l0_n;
			bool NV_n;
			bool NZV_n;
			word32 l1_n;
			fn00000001();
			fprintf(&globals->t2B640, "%s: ", o2);
			fprintf(&globals->t2B640, globals->ptr28078, o0);
			fprintf(&globals->t2B640, ": %s\n", xstrerror(globals->ptr2B760));
			exit(~0x00);
		}
		else
		{
			if (o0_n != 0x00)
				close(o0_n);
			if (dwLoc24_n != 0x01)
			{
				close(dwLoc24_n);
				i0_n = l1;
			}
			else
				i0_n = l1;
			return i0_n;
		}
	}
	o0_n = 0x00017B20;
l00016B10:
	*o4 = o0_n;
	*o5 = 0x00;
	i0_n = ~0x00;
	return i0_n;
}

// 00016C2C: Register word32 pwait(Register (ptr32 int32) o1, Register out ptr32 i2Out, Register out ptr32 i6Out)
word32 pwait(int32 * o1, ptr32 & i2Out, ptr32 & i6Out)
{
	wait(o1);
	word32 i2_n;
	*i2Out = o2;
	word32 i6_n;
	*i6Out = fp;
	return o0;
}

// 00016C40: Register Eq_n mkstemps(Register Eq_n o0, Register Eq_n o1)
Eq_n mkstemps(Eq_n o0, Eq_n o1)
{
	Eq_n i0_n;
	Eq_n o0_n = strlen(o0);
	if (o0_n - (o1 + 0x06) >= 0x00)
	{
		word32 o0_n = o0_n - (o1 + 0x06);
		word32 i1_n = o0 + o0_n;
		if (strncmp(i1_n, 0x00017B78, 0x06) != 0x00)
			&i0_n.u0->b0000 = ~0x00;
		else
		{
			gettimeofday(fp + ~0x17, null);
			Eq_n o0_n = getpid();
			ui32 o1_n = dwLoc14 >> 0x1F << 0x10;
			ui32 o5_n = dwLoc14 << 0x10 ^ dwLoc18 ^ o0_n;
			Eq_n o4_n = (dwLoc14 >> 0x10 | o1_n) ^ dwLoc18 >> 0x1F ^ o0_n >> 0x1F;
			Mem147[0x0002B400:word64] = Mem0[0x0002B400:word64] + o4_n + (o1_n + o5_n <u 0x00);
			while (true)
			{
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				byte * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				*i1_n = (byte) (word32) o1_n->b17B38;
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				word32 i1_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__udiv64();
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				struct Eq_n * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				i1_n->b0001 = (byte) (word32) o1_n->b17B38;
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				word32 i1_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__udiv64();
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				struct Eq_n * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				i1_n->b0002 = (byte) (word32) o1_n->b17B38;
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				word32 i1_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__udiv64();
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				struct Eq_n * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				i1_n->b0003 = (byte) (word32) o1_n->b17B38;
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				word32 i1_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__udiv64();
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				struct Eq_n * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				i1_n->b0004 = (byte) (word32) o1_n->b17B38;
				word32 sp_n;
				word32 i0_n;
				word32 o0_n;
				word32 i1_n;
				word32 o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				word32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__udiv64();
				word32 sp_n;
				Eq_n i0_n;
				word32 o0_n;
				struct Eq_n * i1_n;
				struct Eq_n * o1_n;
				word32 i2_n;
				word32 o2_n;
				word32 i3_n;
				word32 o3_n;
				word32 i4_n;
				word32 o4_n;
				word32 i5_n;
				word32 o5_n;
				word32 i6_n;
				word32 i7_n;
				word32 o7_n;
				word32 g0_n;
				byte NZVC_n;
				bool NZV_n;
				byte Z_n;
				int32 l3_n;
				word32 g3_n;
				word32 g2_n;
				word32 l1_n;
				word32 l0_n;
				bool C_n;
				word32 l4_n;
				word32 l5_n;
				word32 l2_n;
				bool NV_n;
				__urem64();
				i1_n->b0005 = (byte) (word32) o1_n->b17B38;
				Eq_n o0_n = open(i0_n, 0x0502);
				if (o0_n >= 0x00)
					break;
				Eq_n o2_n = globals->t2B400;
				if (l3_n > 0x44A6)
				{
					globals->t2B400 = o2_n;
					*i0_n = 0x00;
					goto l00016E58;
				}
				globals->t2B400 = o2_n;
			}
			i0_n = o0_n;
		}
	}
	else
	{
l00016E58:
		&i0_n.u0->b0000 = ~0x00;
	}
	return i0_n;
}

// 00016E64: Register word32 fn00016E64(Register word32 o7, Register word32 l7)
word32 fn00016E64(word32 o7, word32 l7)
{
	return o7 + l7;
}

// 00016E6C: Register (ptr32 word32) __do_global_ctors_aux(Register word32 o7)
word32 * __do_global_ctors_aux(word32 o7)
{
	word32 * l0_n;
	struct Eq_n * l7_n = fn00016E64(o7, 0x00010D08);
	struct Eq_n * o1_n = l7_n->ptr0014;
	word32 o2_n = o1_n->dwFFFFFFFC;
	if (o2_n != ~0x00)
	{
		do
		{
			word32 sp_n;
			word32 i0_n;
			word32 o0_n;
			word32 i1_n;
			word32 o1_n;
			word32 i2_n;
			word32 o2_n;
			word32 i3_n;
			word32 o3_n;
			word32 i4_n;
			word32 o4_n;
			word32 i5_n;
			word32 o5_n;
			word32 i6_n;
			word32 i7_n;
			word32 o7_n;
			word32 l7_n;
			word32 g0_n;
			byte NZVC_n;
			byte Z_n;
			fn00000014();
		} while (*l0_n != ~0x00);
	}
	else
		l0_n = (word32 *) &o1_n->dwFFFFFFFC;
	return l0_n;
}

// 00016EBC: void init_dummy()
void init_dummy()
{
}

// 00016EC8: Register word32 _init(Register word32 o7)
word32 _init(word32 o7)
{
	frame_dummy(o7);
	return __do_global_ctors_aux(o7);
}

// 00016EE4: void _fini(Register word32 o7)
void _fini(word32 o7)
{
	__do_global_dtors_aux(o7);
}

// 00027C68: void atexit()
void atexit()
{
}

// 00027C74: void exit()
void exit()
{
}

// 00027C80: void _exit()
void _exit()
{
}

// 00027CA4: void vfprintf()
void vfprintf()
{
}

// 00027CB0: void strerror()
void strerror()
{
}

// 00027CBC: void malloc()
void malloc()
{
}

// 00027CC8: void realloc()
void realloc()
{
}

// 00027CD4: void free()
void free()
{
}

// 00027CE0: void strcpy()
void strcpy()
{
}

// 00027CEC: void strncpy()
void strncpy()
{
}

// 00027CF8: void read()
void read()
{
}

// 00027D04: void write()
void write()
{
}

// 00027D10: void abort()
void abort()
{
}

// 00027D1C: void strlen()
void strlen()
{
}

// 00027D28: void strncmp()
void strncmp()
{
}

// 00027D34: void strcmp()
void strcmp()
{
}

// 00027D40: void stat()
void stat()
{
}

// 00027D4C: void atoi()
void atoi()
{
}

// 00027D58: void memcpy()
void memcpy()
{
}

// 00027D64: void fprintf()
void fprintf()
{
}

// 00027D70: void strcat()
void strcat()
{
}

// 00027D7C: void access()
void access()
{
}

// 00027D88: void open()
void open()
{
}

// 00027D94: void close()
void close()
{
}

// 00027DA0: void unlink()
void unlink()
{
}

// 00027DAC: void strrchr()
void strrchr()
{
}

// 00027DB8: void longjmp()
void longjmp()
{
}

// 00027DC4: void setjmp()
void setjmp()
{
}

// 00027DD0: void fflush()
void fflush()
{
}

// 00027DDC: void link()
void link()
{
}

// 00027DE8: void creat()
void creat()
{
}

// 00027DF4: void chmod()
void chmod()
{
}

// 00027E00: void setlocale()
void setlocale()
{
}

// 00027E0C: void getenv()
void getenv()
{
}

// 00027E18: void getcwd()
void getcwd()
{
}

// 00027E24: void fputs()
void fputs()
{
}

// 00027E30: void mktemp()
void mktemp()
{
}

// 00027E3C: void execvp()
void execvp()
{
}

// 00027E48: void execv()
void execv()
{
}

// 00027E54: void pipe()
void pipe()
{
}

// 00027E60: void sleep()
void sleep()
{
}

// 00027E6C: void vfork()
void vfork()
{
}

// 00027E78: void dup()
void dup()
{
}

// 00027E84: void wait()
void wait()
{
}

// 00027E90: void gettimeofday()
void gettimeofday()
{
}

// 00027E9C: void getpid()
void getpid()
{
}

// 00027EA8: void __urem64()
void __urem64()
{
}

// 00027EB4: void __udiv64()
void __udiv64()
{
}

